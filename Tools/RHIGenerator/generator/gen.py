from generator.loader import ProtypeLoader
from generator.name import NameUtil, TypeRegEx, make_enum_name, make_enum_value, make_struct_name, make_name_XXX_XXX, make_name_AxxBxx
import re, os

re_param = re.compile('(Nullable|NotNull)*\s*(const)*\s*(?P<name>[\w\s]*\w)', re.I)
re_array = re.compile('(?P<name>.*)\[\d+\]', re.I)

license_tsinstudio = '''/**
This header was generated by `sappheiros` (https://github.com/Tomicyo/sappheiros)
Copyright (c) 2017 Tsin Studio

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
**/
'''
api_def = '''
#if _WIN32
  #if defined(LIB_BUILD)
    #if defined(BUILD_SHARED_LIB)
      #define NGFX_API __declspec(dllexport)
    #else
      #define NGFX_API __declspec(dllimport)
    #endif
  #else
    #define NGFX_API     
  #endif
#else
  #define NGFX_API __attribute__((visibility("default"))) 
#endif
'''

annotation_def = '''
#if _MSC_VER
#define Nullable _In_opt_
#define NotNull _In_
#else
#define Nullable  
#define NotNull  
#endif
'''


refercounted_src = '''
template <bool ThreadSafe>
struct {0}RefCounted
{{
  {0}RefCounted() {{}}
  virtual ~{0}RefCounted() {{}}
  int32_t AddInternalRef()
  {{
    return __k3d_intrinsics__::AtomicIncrement(&m_IntRef);
  }}
  int32_t ReleaseInternal()
  {{
    auto c = __k3d_intrinsics__::AtomicDecrement(&m_IntRef);
    if (m_IntRef == 0)
    {{
      delete this;
    }}
    return c;
  }}
  int32_t Release()
  {{
    auto c = __k3d_intrinsics__::AtomicDecrement(&m_ExtRef);
    if (m_ExtRef == 0)
    {{
      ReleaseInternal();
    }}
    return c;
  }}
  int32_t AddRef()
  {{
    return __k3d_intrinsics__::AtomicIncrement(&m_ExtRef);
  }}
private:
  int32_t m_IntRef = 1;
  int32_t m_ExtRef = 1;
}};
/* Unthread-safe RefCounted*/
template <>
struct {0}RefCounted<false>
{{
  {0}RefCounted() {{}}
  virtual ~{0}RefCounted() {{}}
  int32_t AddInternalRef()
  {{
    m_IntRef++;
    return m_IntRef;
  }}
  int32_t ReleaseInternal()
  {{
    m_IntRef--;
    int32_t c = m_IntRef;
    if (m_IntRef == 0)
    {{
      delete this;
    }}
    return c;
  }}
  int32_t Release()
  {{
    m_ExtRef--;
    int32_t c = m_ExtRef;
    if (m_ExtRef == 0)
    {{
      ReleaseInternal();
    }}
    return c;
  }}
  int32_t AddRef()
  {{
    m_ExtRef++;
    return m_ExtRef;
  }}
private:
  int32_t m_IntRef = 1;
  int32_t m_ExtRef = 1;
}};
template <bool ThreadSafe>
struct {0}NamedObject : public {0}RefCounted<ThreadSafe>
{{
  virtual void SetName(const char *) {{}}
protected:
  void operator delete (void * Ptr)
  {{
    __k3d_free__(Ptr, 0);
  }}
}};
template <class NGFXObj>
class {0}Ptr
{{
public:
  explicit {0}Ptr(NGFXObj * pObj)
    : m_Ptr(pObj)
  {{}}
  {0}Ptr({0}Ptr<NGFXObj> const& Other)
    : m_Ptr(Other.m_Ptr)
  {{
    if(m_Ptr)
      m_Ptr->AddInternalRef();
  }}
  {0}Ptr()
    : m_Ptr(nullptr)
  {{
  }}
  ~{0}Ptr()
  {{
    if (m_Ptr)
    {{
      m_Ptr->ReleaseInternal();
    }}
    m_Ptr = nullptr;
  }}
  NGFXObj& operator*() const {{ return *m_Ptr; }}
  NGFXObj* operator->() const {{ return m_Ptr; }}
  explicit operator bool() const
  {{
    return m_Ptr != nullptr;
  }}
  void Swap({0}Ptr& Other)
  {{
    NGFXObj * const pValue = Other.m_Ptr;
    Other.m_Ptr = m_Ptr;
    m_Ptr = pValue;
  }}
  {0}Ptr& operator=(const {0}Ptr& Other)
  {{
    typedef {0}Ptr<NGFXObj> ThisType;
    if (&Other != this)
    {{
      ThisType(Other).Swap(*this);
    }}
    return *this;
  }}
  NGFXObj* Get() const
  {{
    return m_Ptr;
  }}
  NGFXObj** GetAddressOf()
  {{
    return &m_Ptr;
  }}
private:
  NGFXObj* m_Ptr;
}};
'''

bit_src = '''
template <typename TEnum>
class EnumAsUint32
{
public:
  static_assert(__is_enum(TEnum), "TEnum is enum!");
  EnumAsUint32(uint32_t Val = 0) : Value(Val) {}
  EnumAsUint32(TEnum eVal) : Value(static_cast<uint32_t>(eVal)) {}
  void operator |= (const TEnum& rhs)
  {
    Value |= static_cast<uint32_t>(rhs);
  }
  void operator &= (const TEnum& rhs)
  {
    Value &= static_cast<uint32_t>(rhs);
  }
  void operator ^= (const TEnum& rhs)
  {
    Value ^= static_cast<uint32_t>(rhs);
  }
  EnumAsUint32<TEnum> operator ~()
  {
    return EnumAsUint32<TEnum>(~Value);
  }
  uint32_t Value;
};

template <typename TEnum>
inline bool operator & (const EnumAsUint32<TEnum>& Lhs, const TEnum& Rhs)
{
  return Lhs.Value & static_cast<uint32_t>(Rhs);
}
'''

class TemplateGenerator(object):
    'template generator'
    def __init__(self):
        self.ns = ''
        self.type_tree = {}

    def gen(self, templ, outpath=''):
        if isinstance(templ, ProtypeLoader):
            print('generating ...', outpath)
            self.content = templ.__type_dict__
            self.type_tree = templ.type_tree

            dir_ = os.path.dirname(outpath)
            (headername,extension) = os.path.splitext(os.path.basename(outpath))
            if not os.path.exists(dir_) and dir_ != '':
                os.makedirs(dir_)

            import_names = self.gen_imports(templ.imports, self.content, dir_)
            self.ns = templ.namespace
            self.is_cpp = templ.__cpp__

            self.__header__ = open(outpath, 'w')
            self.__table__ = open('table.h', 'w')
            self.__header__.write(license_tsinstudio)
            self.__header__.write('#pragma once\n#ifndef __{0}__\n#define __{0}__\n' .format( headername.upper()) )
            for include in import_names:
                self.__header__.write('#include \"%s.h\"\n' % include)

            self.__header__.write('#include <stdint.h>\n#include <string.h>\n')
            
            self.__header__.write(api_def)

            self.__header__.write(annotation_def)

            self.__header__.write(
'''
typedef float    Float32;
typedef uint32_t Bool32;
typedef struct   Float32x4 { Float32 x,y,z,w;
#if __cplusplus
                 Float32x4(Float32 _x = 0, Float32 _y = 0, Float32 _z = 0, Float32 _w = 0)
                 : x(_x), y(_y), z(_z), w(_w) {}
#endif
                 } Float32x4;
'''
              )

            if templ.__cpp__:
                self.__header__.write('\nnamespace {0}\n{{'.format(self.ns))

            # C Section
            for enum in templ.enums:
                self.write_enum(enum)

            for interface in templ.interfaces:
                self.write_interface_forward_decl(interface)
            self.__header__.write('\n')

            for struct in templ.structs:
                self.write_struct(struct)
            # End C Section

            if not templ.__cpp__:
                self.__header__.write('\n#if __cplusplus\n')
            # Cpp Section
                self.__header__.write('\nnamespace {0}\n{{'.format(self.ns))

            self.__header__.write(refercounted_src.format(''))

            self.__header__.write(bit_src)

            for enum in templ.enums:
                self.write_enum(enum, True)

            for interface in templ.interfaces:
                self.write_interface_forward_decl(interface, True)
            self.__header__.write('\n')

            for struct in templ.structs:
                self.write_struct(struct, True)
            
            for interface in templ.interfaces:
                self.write_interface(interface, True)

            for function in templ.functions:
                self.write_function(function)

            if len(templ.classes) > 0:
                self.__source__ = open(os.path.join(dir_, headername + '.cpp'), 'w')
                self.__source__.write('#include \"%s.h\"\n' % headername)
                if templ.__cpp__:
                    self.__source__.write('\nnamespace %s \n{\n' % self.ns)

            for class_ in templ.classes:
                self.write_class(class_)

            if len(templ.classes) > 0 and templ.__cpp__:
                self.__source__.write('\n} // end %s\n' % self.ns)
            
            if templ.__cpp__:
                self.__header__.write('\n} // namespace %s' % self.ns)
            else:
                self.__header__.write('\n} // namespace %s' % self.ns)
                self.__header__.write('\n#endif // __cplusplus\n')

            self.__header__.write('\n#endif // __%s__\n' % headername.upper())
                                    
        else:
            print('Error')

    def gen_imports(self, _import, content_dict, dir_):
        import_names = []
        if _import:
            for import_templ in _import:
                tp = ProtypeLoader(import_templ)
                i_name = ''
                self.content = dict(self.content, **tp.__type_dict__)
                self.type_tree = dict(self.type_tree, **tp.type_tree)
                if '.yml' in import_templ:
                    i_name = import_templ[:-4]
                self.gen(tp, os.path.join(dir_, i_name + '.h'))
                import_names.append(i_name)
        return import_names

    def write_interface_forward_decl(self, interface, is_cpp=False):
        interface_name = interface['interface']
        if is_cpp:
            self.__header__.write('\nstruct {0};'.format(NameUtil['cpp_interface'](self.ns, interface_name)))
        else:
            self.__header__.write('\ntypedef struct _{0}* {0};'.format(NameUtil['interface'](self.ns, interface_name)))

    def write_interface(self, interface, is_cpp=False):
        interface_name = interface['interface']
        real_interface_name = NameUtil['cpp_interface' if is_cpp else 'interface'](self.ns, interface_name)
        interface_protype = interface['val']
        #self.__header__.write('\ntypedef {0}_T* {0};\n'.format(real_interface_name))
        interface_head = ''
        # write comment
        if 'comment' in interface_protype:
            self.__header__.write('\n// {0}'.format(interface_protype['comment'])) 
        if 'inherit' in interface_protype:
            inherit_name = interface_protype['inherit']
            real_inherit_name = NameUtil['cpp_interface' if is_cpp else 'interface'](self.ns, inherit_name)
            interface_head = '\nstruct {0} : public {1}\n{{\n'.format(real_interface_name, real_inherit_name)
        else:
            interface_head = '\nstruct {0}\n{{\n'.format(real_interface_name)
        if 'functions' not in interface_protype and 'inherit' not in interface_protype:
            return
        self.__header__.write(interface_head)
        if 'functions' in interface_protype:
            for function in interface_protype['functions']:
                if isinstance(function, dict):
                    for (func_name, func_val) in function.items():
                        self.gen_interface_function(func_name, func_val, is_cpp)
                else:
                    self.gen_interface_function(function, None, is_cpp)
        self.__header__.write('};\n')

    def gen_interface_function(self, func_name, function=None, is_cpp=False):
        ret = 'void'
        real_func_name = NameUtil['function']('', func_name)
        if not function:
            self.__header__.write('  virtual {0} {1}() = 0;\n'.format(ret, real_func_name))
        else:
            if 'return' in function:
                ret = self.get_real_type_name(function['return'], None, is_cpp)
            param_list = []
            if 'params' in function:
                params = function['params']
                for param in params:
                    if not param:
                        continue
                    if 'type' not in param:
                        print(param, 'error')
                    param_type = param['type']
                    r_param_type = self.get_real_type_name(param_type, None, is_cpp)
                    param_list.append(' '.join([r_param_type, param['name']]))

            self.__header__.write('  virtual {0} {1}('.format(ret, real_func_name))
            self.__header__.write(', '.join(param_list))
            self.__header__.write(') const = 0;\n' if 'const' in function else ') = 0;\n')

    def get_real_type_name(self, type_name, ns=None, is_cpp=False):
        r_type_name = type_name
        real_param_t = re_param.findall(type_name)[0][2]
        if real_param_t in self.content:
            param_t_name = self.content[real_param_t]
            real_param_t_name = NameUtil[(('cpp_' + param_t_name) if is_cpp else param_t_name)](self.ns if ns==None else ns, real_param_t)
            #r_type_name = re_param.sub(r'\1 ' + real_param_t_name, type_name) python 3.5
            r_type_name = TypeRegEx.sub('\g<annotate> ' + '\g<const>'+ real_param_t_name + '\g<pointer>', type_name)

        if r_type_name[0:1] == ' ':
            r_type_name = r_type_name[1:]

        return r_type_name

    def write_function(self, function, is_cpp=True):
        func_decl = function['val']
        ret = 'void' if 'return' not in func_decl else func_decl['return']
        exported = 'exported' in func_decl
        ret_type = self.get_real_type_name(ret, None, is_cpp)
        if exported:
          self.__header__.write('\n{0} NGFX_API {1}'.format(ret_type, make_name_AxxBxx(function['function'])))
        else:
          self.__header__.write('\n{0} {1}'.format(ret_type, make_name_AxxBxx(function['function'])))

        if 'params' in func_decl:
            self.__header__.write('(')
            paralist = []
            for param in func_decl['params']:
              param_name = param['name']
              param_t = param['type']
              paralist.append('{0} {1}'.format(self.get_real_type_name(param_t, None, is_cpp), param_name))
            paralist_str = ', '.join(paralist)
            self.__header__.write(paralist_str+');\n')

    def write_enum(self, enum, is_cpp=False):
        enum_name = enum['enum']
        val = enum['val']
        enum_vals = val['enums']
        # write comment
        if 'comment' in val:
            self.__header__.write('\n// {0}'.format(val['comment'])) 
        
        r_enum_name = NameUtil['cpp_enum' if is_cpp else 'enum'](self.ns, enum_name)
        if not is_cpp:
            self.__header__.write('\ntypedef enum {0}\n{{\n'.format(r_enum_name))
            bit = 1
            for enum_val in enum_vals:
                if not isinstance(enum_val, dict):
                    enum_val_name = make_enum_value(make_name_XXX_XXX(enum_name), enum_val)
                else:
                    enum_val_name = make_enum_value(make_name_XXX_XXX(enum_name), enum_val.keys()[0])
                    # write table

                if self.ns:
                    enum_val_name = self.ns.upper() + '_' + enum_val_name
                if 'bitmask' in val:
                    self.__header__.write('  {0} = {1},\n'.format(enum_val_name, bit))
                    bit = bit << 1
                else:
                    self.__header__.write('  {0},\n'.format(enum_val_name))
            self.__header__.write('}} {0};\n'.format(r_enum_name))
        else:
            self.write_enum_table(enum_name, val, True)
            self.__header__.write('\nenum class {0} : uint32_t\n{{\n'.format(r_enum_name))
            bit = 1
            for enum_val in enum_vals:
                if not isinstance(enum_val, dict):
                    enum_val_name = make_name_AxxBxx(enum_val)
                else:
                    enum_val_name = make_name_AxxBxx(enum_val.keys()[0])
                    # write table

                #if self.ns:
                #    enum_val_name = self.ns.upper() + '_' + enum_val_name
                if 'bitmask' in val:
                    self.__header__.write('  {0} = {1},\n'.format(enum_val_name, bit))
                    bit = bit << 1
                else:
                    self.__header__.write('  {0},\n'.format(enum_val_name))
            self.__header__.write('}};// Enum {0}\n'.format(r_enum_name))

    def write_enum_table(self, enum_name, enum_tree, is_cpp):
        if 'vulkan' in enum_tree and is_cpp:
          enum_values = enum_tree['enums']
          real_converted_enum = enum_tree['vulkan']
          real_enum_name = NameUtil['cpp_enum' if is_cpp else 'enum'](self.ns, enum_name)
          table_src = '{0} Convert{1}ToVulkanEnum({2} const& e) {{\n  switch(e) {{\n'.format(real_converted_enum, make_name_AxxBxx(enum_name), real_enum_name)
          for enum_val in enum_values:
            converted_val = enum_val[enum_val.keys()[0]]['vulkan']
            enum_val_name = '::'.join([real_enum_name, make_name_AxxBxx(enum_val.keys()[0])])
            case_sec = '  case {0}:\n    return {1};\n'.format(enum_val_name, converted_val)
            table_src = table_src + case_sec
          table_src = table_src + '  }\n}\n'
          self.__table__.write(table_src)
        elif 'glslang' in enum_tree and is_cpp:
          enum_values = enum_tree['enums']
          real_converted_enum = enum_tree['glslang']
          real_enum_name = NameUtil['cpp_enum' if is_cpp else 'enum'](self.ns, enum_name)
          table_src = '{0} Convert{1}ToGlslangEnum({2} const& e) {{\n  switch(e) {{\n'.format(real_converted_enum, make_name_AxxBxx(enum_name), real_enum_name)
          for enum_val in enum_values:
            converted_val = enum_val[enum_val.keys()[0]]['glslang']
            enum_val_name = '::'.join([real_enum_name, make_name_AxxBxx(enum_val.keys()[0])])
            case_sec = '  case {0}:\n    return {1};\n'.format(enum_val_name, converted_val)
            table_src = table_src + case_sec
          table_src = table_src + '  }\n}\n'
          self.__table__.write(table_src)

    def write_struct(self, struct, is_cpp=False):
        struct_name = struct['struct']
        struct_members = struct['val']['members']
        # write comment
        if 'comment' in struct['val']:
            self.__header__.write('\n// {0}'.format(struct['val']['comment']))

        r_struct_name = NameUtil['cpp_struct' if is_cpp else 'struct'](self.ns, struct_name)
        has_inherit = 'inherit' in struct['val']
        inherit_type = None
        inherit_type_tree = None;
        if is_cpp:
          if has_inherit:
            inherit_type = NameUtil['cpp_struct'](self.ns, struct['val']['inherit'])
            inherit_type_tree = self.type_tree[self.ns]['struct'][struct['val']['inherit']]['members']
            self.__header__.write('\nstruct {0} : public {1}\n{{\n'.format(r_struct_name, inherit_type))
          else:
            self.__header__.write('\nstruct {0}\n{{\n'.format(r_struct_name))
        else:
          self.__header__.write('\nstruct {0}\n{{\n'.format(r_struct_name))
          if has_inherit:
            inherit_type_tree = self.type_tree[self.ns]['struct'][struct['val']['inherit']]['members']
            tmp_list = []
            tmp_list.extend(inherit_type_tree)
            tmp_list.extend(struct_members)
            struct_members = tmp_list

        member_setters = []
        #member_params = []
        member_params_str = []
        init_list_str = []
        init_body_str = []
        array_members = []
        for member in struct_members:
            if not member:
                continue
            member_type = member['type']
            is_bitmask = self.isBitmask(member_type)
            def_val = self.getDefaultValue(member_type)
            is_array = False
            member_name = member['name']

            if member_type in self.content:
                member_type = NameUtil[('cpp_' + self.content[member_type]) if is_cpp else self.content[member_type]](self.ns, member_type)
            elif not self.isBasicType(member_type):
                member_type = self.get_real_type_name(member_type, self.ns, is_cpp)

            self.__header__.write('  {0} {1};\n'.format(
            'EnumAsUint32<{0}>'.format(member_type) if is_bitmask and is_cpp else member_type, 
            member_name))
            # skip array members functions
            if re_array.findall(member_name):
                array_name = re_array.match(member_name).group('name')
                if not array_name.endswith('s'):
                    print('array name should end with \'s\'', array_name)
                m_func_name = 'Set%s' % make_struct_name('', array_name[:-1])
                member_name = array_name
                init_body_str.append('\n    memset({0}, 0, sizeof({0}));\n'.format(array_name))
                is_array = True
            else:
                m_func_name = 'Set%s' % make_struct_name('', member_name)
            
            m_func_param = (member_type, member_name)
            m_setter = {
                'func': m_func_name,
                'param': m_func_param,
                'array': is_array
            }
            member_setters.append(m_setter)
            if ',' in member_name:
                sub_member = member_name.split(',')
                for sub in sub_member:
                    r_sub = self.stripHeadSpace(sub)
                    if def_val:
                      member_params_str.append(' '.join([member_type, '_' + r_sub]) + ' = ' + def_val)
                    else:
                      member_params_str.append(' '.join([member_type, '_' + r_sub]))
                    init_list_str.append('{0}(_{0})'.format(r_sub))
            else:
                if def_val and not is_array:
                  member_params_str.append(' '.join([member_type, '_' + member_name]) + ' = ' + def_val)
                  init_list_str.append('{0}(_{0})'.format(member_name))
                elif not is_array:
                #else:
                  member_params_str.append(' '.join([member_type, '_' + member_name]))
                  init_list_str.append('{0}(_{0})'.format(member_name))

        if is_cpp:
            #self.__header__.write('#if __cplusplus\n')
            # write constructor
            if has_inherit:
              self.__header__.write('\n  {0}({1})\n  : {2}\n  , {3}\n  {{{4}  }}\n'.format(r_struct_name, ', '.join(member_params_str), inherit_type+'()', '\n  , '.join(init_list_str), ''.join(init_body_str)))
            else:
              self.__header__.write('\n  {0}({1})\n  : {2}\n  {{{3}  }}\n'.format(r_struct_name, ', '.join(member_params_str), '\n  , '.join(init_list_str), ''.join(init_body_str)))
            # write member function
            for setter in member_setters:
                if ',' in setter['param'][1]:
                    member_names = setter['param'][1].split(',')
                    member_name_link = ' '.join(member_names)
                    func_name = 'Set%s' % make_struct_name('', member_name_link)
                    m_func_params = []
                    m_func_impl = []
                    for m_name in member_names:
                        rm_name = self.stripHeadSpace(m_name)
                        m_func_params.append('{0} _{1}'.format(setter['param'][0], rm_name))
                        m_func_impl.append('{0} = _{0};'.format(rm_name))
                    self.__header__.write('\n  {0}& {1}({2})\n  {{\n    {3}\n    return *this;\n  }}\n'.
                        format(r_struct_name, func_name, ', '.join(m_func_params), '\n    '.join(m_func_impl)))
                elif setter['array']:
                    self.__header__.write('\n  {0}& {1}(int index, {2} _{3})\n  {{\n    {3}[index] = _{3};\n    return *this;\n  }}\n'.
                        format(r_struct_name, setter['func'], setter['param'][0], setter['param'][1]))
                else:
                    self.__header__.write('\n  {0}& {1}({2} _{3})\n  {{\n    {3} = _{3};\n    return *this;\n  }}\n'.
                        format(r_struct_name, setter['func'], setter['param'][0], setter['param'][1]))
            #self.__header__.write('#endif\n')
        
        self.__header__.write('};\n')

        if is_cpp:
            # need static_assert
            self.__header__.write('\nstatic_assert(sizeof({0}) == sizeof({1}), \"{0} & {1} Size Not Equal!\");\n'.format(r_struct_name, NameUtil['struct'](self.ns, struct_name)))

    def isBasicType(self, t):
        basicType = ['uint32_t', 'uint64_t', 'float32', 'bool', 'float', 'int32_t', 'Bool32', 'Float32']
        return t in basicType

    def isBitmask(self, t):
        if t in self.type_tree[self.ns]['enum']:
            return 'bitmask' in self.type_tree[self.ns]['enum'][t]
        return False

    def getDefaultValue(self, _type):
      if self.isBasicType(_type):
        return '0'
      elif _type.endswith('*'):
        return 'nullptr'
      elif _type in ['Float32x4']:
        return 'Float32x4()'
      else: # enum value ?
        stat = ''
        if _type in self.type_tree[self.ns]['enum']:
          default_val = self.type_tree[self.ns]['enum'][_type]['enums'][0]
          default_val_t_name = NameUtil['cpp_enum'](self.ns, _type)
          if isinstance(default_val, dict):
            stat = '::'.join([default_val_t_name, make_name_AxxBxx(default_val.keys()[0])])
          else:
            stat = '::'.join([default_val_t_name, make_name_AxxBxx(default_val)])
        elif _type in self.type_tree[self.ns]['struct']:
          stat = NameUtil['cpp_struct'](self.ns, _type) + '()'
        else:
          stat = _type
        return stat

    def stripHeadSpace(self, str_):
        if str_ and str_[0:1] == ' ':
            return self.stripHeadSpace(str_[1:])
        else:
            return str_

    def write_class(self, class_):
        class_name = class_['class']
        class_val = class_['val']
        parent_type_name = ''
        parent_type_ns = ''
        r_cls_name = NameUtil['class'](self.ns if not self.is_cpp else '', class_name)
        if 'inherit' in class_val:
            parent_type = class_val['inherit']
            if '::' in parent_type:
                type_segs = parent_type.split('::')
                len_seg = len(type_segs)
                if len_seg >= 2:
                    parent_type_ns = type_segs[0]
                parent_type_name = type_segs[-1]

                if parent_type_ns in self.type_tree:
                    ptype = self.content[parent_type_name] # return interface / struct
                    pname = NameUtil[ptype](parent_type_ns, parent_type_name)
                    pelem = self.type_tree[parent_type_ns][ptype][parent_type_name]
                    self.__header__.write('\nclass {0} : public {1}\n{{\npublic:\n'.format(r_cls_name, pname))
                    if 'functions' in pelem:
                        for function in pelem['functions']:
                            if isinstance(function, dict):
                                for (func_name, func_val) in function.items():
                                    self.gen_class_function(func_name, function=func_val, class_name=r_cls_name, ns=parent_type_ns)
                            else:
                                self.gen_class_function(function, class_name=r_cls_name, ns=parent_type_ns)
                    # write 'friend class'
                    if 'friends' in class_val:
                        friends_types = class_val['friends']
                        for _f_type in friends_types:
                            self.__header__.write('\n  friend class {0};\n'.
                                format(NameUtil['class'](self.ns if not self.is_cpp else '',
                                _f_type)))

                    # then generate constructor and deconstructor
                    self.__header__.write('private:\n  {0}();\n  ~{0}();\n'.format(r_cls_name))
                    if self.__source__:
                        self.__source__.write('\n{0}::{0}()\n{{\n}}\n'.format(r_cls_name))
                        self.__source__.write('\n{0}::~{0}()\n{{\n}}\n'.format(r_cls_name))

                    if 'holdref' in class_val:
                        hold_refs = class_val['holdref']
                        for h_ref in hold_refs:
                            r_h_ref = NameUtil['class'](self.ns if not self.is_cpp else '', h_ref)
                            self.__header__.write('  {0}* {0}_;\n'.format(r_h_ref))

                    self.__header__.write('};\n')

    def gen_class_function(self, func_name, class_name=None, function=None, ns=None):
        ret = 'void'
        r_ret = ret
        real_func_name = NameUtil['function']('', func_name)
        if not function:
            self.__header__.write('  {0} {1}() override;\n'.format(r_ret, real_func_name))
            if self.__source__:
                self.__source__.write('\n{0} {1}::{2}()\n{{\n}}\n'.format(r_ret, class_name, real_func_name))
        else:
            if 'return' in function:
                ret = function['return']
                r_ret = self.get_real_type_name(ret, ns)
            param_list = []
            if 'params' in function:
                params = function['params']
                for param in params:
                    if not param:
                        continue
                    if 'type' not in param:
                        print(param, 'error')
                    param_type = param['type']
                    r_param_type = self.get_real_type_name(param_type, ns)
                    param_list.append(' '.join([r_param_type, param['name']]))

            self.__header__.write('  {0} {1}('.format(r_ret, real_func_name))
            self.__header__.write(', '.join(param_list))
            self.__header__.write(') override;\n')

            if self.__source__:
                default_ret_statement = ''
                for (ns, val) in self.type_tree.items():
                    for (_type, _type_name_val) in val.items():
                        if ret in _type_name_val:
                            if 'enum' == _type:
                                e_parts = []
                                e_parts.append(ns.upper())
                                eval_parts = ret.upper().split(' ')
                                e_parts.extend(eval_parts)
                                e_parts.append(_type_name_val[ret]['enums'][0].upper())
                                e_val = '_'.join(e_parts)
                                default_ret_statement = '  return ' + e_val + ';\n'
                        elif ret.endswith('*'):
                            default_ret_statement = '  return nullptr;\n'

                self.__source__.write('\n{0} {1}::{2}({3})\n{{\n{4}}}\n'.format(r_ret, class_name, real_func_name, ', '.join(param_list), default_ret_statement))

        
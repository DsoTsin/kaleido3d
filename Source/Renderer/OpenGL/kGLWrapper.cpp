#include "kGLWrapper.h"

#ifdef USE_QT_OPENGL
#include <QOpenGLFunctions_4_3_Core>
#else
#include <GL/glew.h>
#endif

#include <Core/k3dLog.h>
#include <Core/k3dDbg.h>

namespace kGL {

  int CreateTexture2DArray(int width, int height, int layerCount, int fillFmt)
  {
    GLuint texture;
    glGenTextures(1,&texture);
    glBindTexture(GL_TEXTURE_2D_ARRAY, texture);
    glTexStorage3D(GL_TEXTURE_2D_ARRAY, 1, fillFmt, width, height, layerCount);
    //Always set reasonable texture parameters
    glTexParameteri(GL_TEXTURE_2D_ARRAY,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D_ARRAY,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D_ARRAY,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D_ARRAY,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);
    return texture;
  }



  uint64 BindlessTexture(int *texIds, int texCount)
  {
      GLuint64 a;
    /*GLuint64 handle = */glMakeTextureHandleResidentARB(a);
      return a;
  }

  int CreateVertexArrayWithIndexBuffer(int vboSize, float *vboPtr, int indexSize, int *indexPtr, int vertLoc)
  {
    GLuint vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    GLuint vbo[2];
    glGenBuffers(2, vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
    glBufferData(GL_ARRAY_BUFFER, vboSize, vboPtr, GL_STATIC_DRAW);
    glVertexAttribPointer(vertLoc, 3, GL_FLOAT, GL_FALSE, 0, NULL);
    glEnableVertexAttribArray(vertLoc);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo[1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indexSize, indexPtr, GL_STATIC_DRAW);
		glBindVertexArray(0);
		assert(glGetError() == GL_NO_ERROR);
        return vao;
  }

  bool CheckFrameBuffer(uint32 framebufferId)
  {
    K3D_UNUSED(framebufferId);
    GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    switch(Status)
    {
    case GL_FRAMEBUFFER_UNDEFINED:
      kDebug("OpenGL Error(%s)\n", "GL_FRAMEBUFFER_UNDEFINED");
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      kDebug("OpenGL Error(%s)\n", "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      kDebug("OpenGL Error(%s)\n", "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
      kDebug("OpenGL Error(%s)\n", "GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER");
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
      kDebug("OpenGL Error(%s)\n", "GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER");
      break;
    case GL_FRAMEBUFFER_UNSUPPORTED:
      kDebug("OpenGL Error(%s)\n", "GL_FRAMEBUFFER_UNSUPPORTED");
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
      kDebug("OpenGL Error(%s)\n", "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE");
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:
      kDebug("OpenGL Error(%s)\n", "GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS");
      break;
    case GL_FRAMEBUFFER_COMPLETE:
      //glf::Info("OpenGL OK(%s)\n", "GL_FRAMEBUFFER_COMPLETE");
      break;
    default:
      kDebug("OpenGL Error(%d !=GL_FRAMEBUFFER_COMPLETE(%d))\n", Status,GL_FRAMEBUFFER_COMPLETE);
    }
    return Status == GL_FRAMEBUFFER_COMPLETE;
  }


  uint32 GetUniformLocation(const char*uniformName, uint32 shaderHandle) {
    uint32 location = glGetUniformLocation(shaderHandle, uniformName);
    if(location == GL_INVALID_OPERATION) {
      kDebug("program is not a program object!\n");
    }
    else if(location == -1 ) {
      kDebug("cannot find uniform(%s)!\n", uniformName);
    }
    else if(GL_INVALID_VALUE == location) {
      kDebug("program is not a value generated by OpenGL!\n");
    }
    return location;
  }
}

/**
This header was generated by `sappheiros` (https://github.com/Tomicyo/sappheiros)
Copyright (c) 2017 Tsin Studio

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
**/
#pragma once
#ifndef __NGFX__
#define __NGFX__
#include <stdint.h>

typedef float    Float32;
typedef uint32_t Bool32;
typedef struct { Float32 x,y,z,w; } Float32x4;

// Result of every call
typedef enum ngfxResult
{
  NGFX_RESULT_OK,
  NGFX_RESULT_FAILED,
  NGFX_RESULT_PARAM_ERROR,
  NGFX_RESULT_DEVICE_NOT_FOUND,
} ngfxResult;

typedef enum ngfxPipelineType
{
  NGFX_PIPELINE_TYPE_GRAPHICS,
  NGFX_PIPELINE_TYPE_COMPUTE,
} ngfxPipelineType;

// Pixel format in storage
typedef enum ngfxPixelFormat
{
  NGFX_PIXEL_FORMAT_RGBA16UINT,
  NGFX_PIXEL_FORMAT_RGBA32FLOAT,
  NGFX_PIXEL_FORMAT_RGBA8UNORM,
  NGFX_PIXEL_FORMAT_RGBA8UNORM_SRGB,
  NGFX_PIXEL_FORMAT_R11G11B10FLOAT,
  NGFX_PIXEL_FORMAT_D32FLOAT,
  NGFX_PIXEL_FORMAT_RGB32FLOAT,
} ngfxPixelFormat;

typedef enum ngfxMultiSampleFlag
{
  NGFX_MULTISAMPLE_FLAG_MS_1X,
  NGFX_MULTISAMPLE_FLAG_MS_2X,
  NGFX_MULTISAMPLE_FLAG_MS_4X,
  NGFX_MULTISAMPLE_FLAG_MS_8X,
  NGFX_MULTISAMPLE_FLAG_MS_16X,
} ngfxMultiSampleFlag;

typedef enum ngfxLoadAction
{
  NGFX_LOAD_ACTION_LOAD,
  NGFX_LOAD_ACTION_CLEAR,
  NGFX_LOAD_ACTION_DONT_CARE,
} ngfxLoadAction;

typedef enum ngfxStoreAction
{
  NGFX_STORE_ACTION_STORE,
  NGFX_STORE_ACTION_DONT_CARE,
} ngfxStoreAction;

typedef enum ngfxVertexFormat
{
  NGFX_VERTEX_FORMAT_F32C,
  NGFX_VERTEX_FORMAT_F32C2,
  NGFX_VERTEX_FORMAT_F32C3,
  NGFX_VERTEX_FORMAT_F32C4,
} ngfxVertexFormat;

typedef enum ngfxPrimitiveType
{
  NGFX_PRIMITIVE_TYPE_POINTS,
  NGFX_PRIMITIVE_TYPE_LINES,
  NGFX_PRIMITIVE_TYPE_TRIANGLES,
  NGFX_PRIMITIVE_TYPE_TRIANGLESTRIPS,
} ngfxPrimitiveType;

typedef enum ngfxBlendOperation
{
  NGFX_BLEND_OPERATION_ADD,
  NGFX_BLEND_OPERATION_SUB,
} ngfxBlendOperation;

// Color blending
typedef enum ngfxBlendType
{
  NGFX_BLEND_TYPE_ZERO,
  NGFX_BLEND_TYPE_ONE,
  NGFX_BLEND_TYPE_SRC_COLOR,
  NGFX_BLEND_TYPE_DST_COLOR,
  NGFX_BLEND_TYPE_SRC_ALPHA,
  NGFX_BLEND_TYPE_DST_ALPHA,
} ngfxBlendType;

typedef enum ngfxStencilOperation
{
  NGFX_STENCIL_OPERATION_KEEP,
  NGFX_STENCIL_OPERATION_ZERO,
  NGFX_STENCIL_OPERATION_REPLACE,
  NGFX_STENCIL_OPERATION_INVERT,
  NGFX_STENCIL_OPERATION_INCREMENT,
  NGFX_STENCIL_OPERATION_DECREMENT,
} ngfxStencilOperation;

typedef enum ngfxComparisonFunction
{
  NGFX_COMPARISON_FUNCTION_NEVER,
  NGFX_COMPARISON_FUNCTION_LESS,
  NGFX_COMPARISON_FUNCTION_EQUAL,
  NGFX_COMPARISON_FUNCTION_LESS_EQUAL,
  NGFX_COMPARISON_FUNCTION_GREATER,
  NGFX_COMPARISON_FUNCTION_NOT_EQUAL,
  NGFX_COMPARISON_FUNCTION_GREATER_EQUAL,
  NGFX_COMPARISON_FUNCTION_ALWAYS,
} ngfxComparisonFunction;

typedef enum ngfxDepthWriteMask
{
  NGFX_DEPTH_WRITE_MASK_ZERO,
  NGFX_DEPTH_WRITE_MASK_ALL,
} ngfxDepthWriteMask;

typedef enum ngfxResourceState
{
  NGFX_RESOURCE_STATE_COMMON = 1,
  NGFX_RESOURCE_STATE_VERTEX_BUFFER = 2,
  NGFX_RESOURCE_STATE_CONSTANT_BUFFER = 4,
  NGFX_RESOURCE_STATE_RENDER_TARGET = 8,
  NGFX_RESOURCE_STATE_PIXEL_SHADER_RESOURCE = 16,
  NGFX_RESOURCE_STATE_TRANSFER_SOURCE = 32,
  NGFX_RESOURCE_STATE_TRANSFER_DEST = 64,
  NGFX_RESOURCE_STATE_PRESENT = 128,
  NGFX_RESOURCE_STATE_GENERIC_READ = 256,
  NGFX_RESOURCE_STATE_UNORDER_ACCESS = 512,
} ngfxResourceState;

typedef enum ngfxResourceViewType
{
  NGFX_RESOURCE_VIEW_TYPE_LINEAR_BUFFER,
  NGFX_RESOURCE_VIEW_TYPE_SAMPLED_TEXTURE,
  NGFX_RESOURCE_VIEW_TYPE_UNORDER_ACCESS_TEXTURE,
  NGFX_RESOURCE_VIEW_TYPE_UNORDER_ACCESS_BUFFER,
} ngfxResourceViewType;

typedef enum ngfxTextureDimension
{
  NGFX_TEXTURE_DIMENSION_TEX1D,
  NGFX_TEXTURE_DIMENSION_TEX2D,
  NGFX_TEXTURE_DIMENSION_TEX2D_MS,
  NGFX_TEXTURE_DIMENSION_TEX2D_ARRAY,
  NGFX_TEXTURE_DIMENSION_TEX3D,
  NGFX_TEXTURE_DIMENSION_TEX3D_ARRAY,
  NGFX_TEXTURE_DIMENSION_TEXCUBE,
} ngfxTextureDimension;

typedef enum ngfxFillMode
{
  NGFX_FILL_MODE_WIRE,
  NGFX_FILL_MODE_SOLID,
} ngfxFillMode;

typedef enum ngfxCullMode
{
  NGFX_CULL_MODE_NONE,
  NGFX_CULL_MODE_FRONT,
  NGFX_CULL_MODE_BACK,
} ngfxCullMode;

typedef enum ngfxFilterMode
{
  NGFX_FILTER_MODE_POINT,
  NGFX_FILTER_MODE_LINEAR,
} ngfxFilterMode;

typedef enum ngfxAddressMode
{
  NGFX_ADDRESS_MODE_WRAP,
  NGFX_ADDRESS_MODE_MIRROR,
  NGFX_ADDRESS_MODE_CLAMP,
  NGFX_ADDRESS_MODE_BORDER,
  NGFX_ADDRESS_MODE_MIRROR_ONCE,
} ngfxAddressMode;

typedef enum ngfxVertexInputRate
{
  NGFX_VERTEX_INPUT_RATE_PERVERTEX,
  NGFX_VERTEX_INPUT_RATE_PERINSTANCE,
} ngfxVertexInputRate;

typedef enum ngfxBindingType
{
  NGFX_BINDING_TYPE_UNIFORM_BUFFER,
  NGFX_BINDING_TYPE_SAMPLER,
  NGFX_BINDING_TYPE_SAMPLED_IMAGE,
  NGFX_BINDING_TYPE_STORAGE_BUFFER,
} ngfxBindingType;

typedef enum ngfxShaderStageBit
{
  NGFX_SHADER_STAGE_BIT_VERTEX = 1,
  NGFX_SHADER_STAGE_BIT_FRAGMENT = 2,
  NGFX_SHADER_STAGE_BIT_COMPUTE = 4,
  NGFX_SHADER_STAGE_BIT_GEOMETRY = 8,
  NGFX_SHADER_STAGE_BIT_TESSAILATIONEVAL = 16,
  NGFX_SHADER_STAGE_BIT_TESSAILATIONCONTROL = 32,
} ngfxShaderStageBit;

typedef enum ngfxShaderFormat
{
  NGFX_SHADER_FORMAT_TEXT,
  NGFX_SHADER_FORMAT_BYTE_CODE,
} ngfxShaderFormat;

typedef enum ngfxShaderLang
{
  NGFX_SHADER_LANG_HLSL,
  NGFX_SHADER_LANG_METALSL,
  NGFX_SHADER_LANG_GLSL,
} ngfxShaderLang;

typedef enum ngfxShaderProfile
{
  NGFX_SHADER_PROFILE_SM4,
  NGFX_SHADER_PROFILE_SM5,
  NGFX_SHADER_PROFILE_SM6,
} ngfxShaderProfile;

typedef enum ngfxShaderDataType
{
  NGFX_SHADER_DATA_TYPE_BOOL,
  NGFX_SHADER_DATA_TYPE_BOOL2,
  NGFX_SHADER_DATA_TYPE_BOOL3,
  NGFX_SHADER_DATA_TYPE_BOOL4,
  NGFX_SHADER_DATA_TYPE_INT,
  NGFX_SHADER_DATA_TYPE_INT2,
  NGFX_SHADER_DATA_TYPE_INT3,
  NGFX_SHADER_DATA_TYPE_INT4,
  NGFX_SHADER_DATA_TYPE_UINT,
  NGFX_SHADER_DATA_TYPE_UINT2,
  NGFX_SHADER_DATA_TYPE_UINT3,
  NGFX_SHADER_DATA_TYPE_UINT4,
  NGFX_SHADER_DATA_TYPE_FLOAT,
  NGFX_SHADER_DATA_TYPE_FLOAT2,
  NGFX_SHADER_DATA_TYPE_FLOAT3,
  NGFX_SHADER_DATA_TYPE_FLOAT4,
  NGFX_SHADER_DATA_TYPE_MAT2,
  NGFX_SHADER_DATA_TYPE_MAT2X3,
  NGFX_SHADER_DATA_TYPE_MAT2X4,
  NGFX_SHADER_DATA_TYPE_MAT3X2,
  NGFX_SHADER_DATA_TYPE_MAT3,
  NGFX_SHADER_DATA_TYPE_MAT3X4,
  NGFX_SHADER_DATA_TYPE_MAT4X2,
  NGFX_SHADER_DATA_TYPE_MAT4,
  NGFX_SHADER_DATA_TYPE_UNKNOWN,
} ngfxShaderDataType;

typedef enum ngfxShaderBindType
{
  NGFX_SHADER_BIND_TYPE_UNDEFINED,
  NGFX_SHADER_BIND_TYPE_BLOCK,
  NGFX_SHADER_BIND_TYPE_SAMPLER,
  NGFX_SHADER_BIND_TYPE_TEXTURE,
  NGFX_SHADER_BIND_TYPE_SAMPLER_TEXTURE,
  NGFX_SHADER_BIND_TYPE_BUFFER,
  NGFX_SHADER_BIND_TYPE_CONSTANT,
} ngfxShaderBindType;

typedef enum ngfxCommandQueueType
{
  NGFX_COMMAND_QUEUE_TYPE_GRAPHICS,
  NGFX_COMMAND_QUEUE_TYPE_COMPUTE,
} ngfxCommandQueueType;

// Type of shader
typedef enum ngfxShaderType
{
  NGFX_SHADER_TYPE_VERTEX,
  NGFX_SHADER_TYPE_FRAGMENT,
  NGFX_SHADER_TYPE_COMPUTE,
  NGFX_SHADER_TYPE_GEOMETRY,
  NGFX_SHADER_TYPE_TESSAILATIONEVAL,
  NGFX_SHADER_TYPE_TESSAILATIONCONTROL,
} ngfxShaderType;

typedef struct _ngfxSwapChain* ngfxSwapChain;
typedef struct _ngfxFunction* ngfxFunction;
typedef struct _ngfxCompiler* ngfxCompiler;
typedef struct _ngfxFactory* ngfxFactory;
typedef struct _ngfxRenderTarget* ngfxRenderTarget;
typedef struct _ngfxRenderPass* ngfxRenderPass;
typedef struct _ngfxPipeline* ngfxPipeline;
typedef struct _ngfxComputePipeline* ngfxComputePipeline;
typedef struct _ngfxRenderPipeline* ngfxRenderPipeline;
typedef struct _ngfxPipelineLayout* ngfxPipelineLayout;
typedef struct _ngfxBindingTable* ngfxBindingTable;
typedef struct _ngfxSampler* ngfxSampler;
typedef struct _ngfxResource* ngfxResource;
typedef struct _ngfxBuffer* ngfxBuffer;
typedef struct _ngfxBufferView* ngfxBufferView;
typedef struct _ngfxTexture* ngfxTexture;
typedef struct _ngfxTextureView* ngfxTextureView;
typedef struct _ngfxDevice* ngfxDevice;
typedef struct _ngfxFence* ngfxFence;
typedef struct _ngfxFrameBuffer* ngfxFrameBuffer;
typedef struct _ngfxCommandQueue* ngfxCommandQueue;
typedef struct _ngfxCommandBuffer* ngfxCommandBuffer;
typedef struct _ngfxCommandEncoder* ngfxCommandEncoder;
typedef struct _ngfxRenderCommandEncoder* ngfxRenderCommandEncoder;
typedef struct _ngfxComputeCommandEncoder* ngfxComputeCommandEncoder;
typedef struct _ngfxParallelRenderCommandEncoder* ngfxParallelRenderCommandEncoder;

struct ngfxDepthStencilOp
{
  ngfxStencilOperation stencilFailOp;
  ngfxStencilOperation depthStencilFailOp;
  ngfxStencilOperation stencilPassOp;
  ngfxComparisonFunction stencilFunc;
};

struct ngfxRasterizerState
{
  ngfxFillMode fillMode;
  ngfxCullMode cullMode;
  Bool32 frontCCW;
  int32_t depthBias;
  Bool32 multiSampleEnable;
};

struct ngfxBlendState
{
  Bool32 enable;
  ngfxBlendType srcColorBlend;
  ngfxBlendType destColorBlend;
  ngfxBlendOperation colorBlendOp;
  ngfxBlendType srcAlphaBlend;
  ngfxBlendType destAlphaBlend;
  ngfxBlendOperation alphaBlendOp;
  uint32_t colorWriteMask;
};

struct ngfxDepthStencilState
{
  Bool32 depthEnable;
  ngfxDepthWriteMask depthWriteMask;
  ngfxComparisonFunction depthFunc;
  Bool32 stencilEnable;
  ngfxDepthStencilOp frontFace;
  ngfxDepthStencilOp backFace;
};

struct ngfxDeviceDesc
{
  uint64_t maxAllocation;
  char * vendorName;
};

struct ngfxFilter
{
  ngfxFilterMode minFilter;
  ngfxFilterMode magFilter;
  ngfxFilterMode mipMapFilter;
};

// Description of sampler
struct ngfxSamplerDesc
{
  ngfxFilter filter;
  ngfxAddressMode U,V,W;
  Float32 mipLodBias;
  uint32_t maxAnistropy;
  ngfxComparisonFunction comparisonFunc;
  Float32 minLod;
  Float32 maxLod;
};

// Description of a buffer
struct ngfxBufferDesc
{
  uint64_t size;
};

// Description of the buffer usage
struct ngfxBufferViewDesc
{
  ngfxResourceViewType view;
  ngfxResourceState state;
  uint64_t size;
  uint64_t offset;
  uint64_t stride;
};

// Description of a texture
struct ngfxTextureDesc
{
  ngfxPixelFormat format;
  uint32_t width;
  uint32_t height;
  uint32_t depth;
  uint32_t layers;
  uint32_t mipLevels;
};

// Description about how the texture be used
struct ngfxTextureViewDesc
{
  ngfxResourceViewType view;
  ngfxResourceState state;
  ngfxTextureDimension dimension;
  uint32_t mipLevel;
};

struct ngfxVertexLayout
{
  ngfxVertexInputRate rate;
  uint32_t stride;
};

struct ngfxVertexAttribute
{
  ngfxVertexFormat format;
  uint32_t offset;
  uint32_t slot;
};

// Vertex input description
struct ngfxVertexInputState
{
  const ngfxVertexAttribute * pAttributes;
  uint32_t attributeCount;
  const ngfxVertexLayout * pLayouts;
  uint32_t layoutCount;
};

// Description of rendering pipeline
struct ngfxRenderPipelineDesc
{
  ngfxRasterizerState rasterState;
  ngfxBlendState blendState;
  ngfxDepthStencilState depthStencil;
  ngfxVertexInputState inputState;
  ngfxPrimitiveType primitiveTopology;
  ngfxFunction * vertexFunction;
  ngfxFunction * pixelFunction;
};

// Description of Pipeline Layout (How to layout bindings)
struct ngfxPipelineLayoutDesc
{
  ngfxShaderStageBit visibility;
  ngfxBindingType bindingType;
  uint32_t slot;
  uint32_t count;
};

struct ngfxAttachmentDesc
{
  ngfxLoadAction loadAction;
  ngfxStoreAction storeAction;
  ngfxTexture * texture;
};

struct ngfxColorAttachmentDesc
{
  Float32x4 clearColor;
};

struct ngfxDepthStencilAttachmentDesc
{
  Float32 clearDepth;
  int32_t clearStencil;
};

// Description of Render Pass
struct ngfxRenderPassDesc
{
  ngfxColorAttachmentDesc * pColorAttachments;
  int32_t colorAttachmentsCount;
  ngfxDepthStencilAttachmentDesc * pDepthStencilAttachment;
};

// Description of Render Target
struct ngfxRenderTargetDesc
{
  int32_t XX;
};

struct ngfxDrawIndexedInstancedDesc
{
  uint32_t indexCountPerInstance;
  uint32_t instanceCount;
  uint32_t startId;
  uint32_t baseVertexId;
  uint32_t startInstanceId;
};

struct ngfxDrawInstancedDesc
{
  uint32_t vertexCountPerInstance;
  uint32_t instanceCount;
  uint32_t startVertexId;
  uint32_t startInstanceId;
};

struct ngfxViewport
{
  Float32 left, top;
  Float32 width, height;
  Float32 minDepth;
  Float32 maxDepth;
};

struct ngfxSwapChainDesc
{
  ngfxPixelFormat pixelFormat;
  uint32_t width;
  uint32_t height;
  uint32_t numColorBuffers;
  Bool32 hasDepthStencilTarget;
  ngfxPixelFormat depthStencilFormat;
};

struct ngfxShaderOption
{
  const char * entryName;
  ngfxShaderProfile profile;
  ngfxShaderFormat format;
};

#if __cplusplus

namespace ngfx
{
template <bool ThreadSafe>
struct RefCounted
{
  RefCounted() {}
  virtual ~RefCounted() {}
  int32_t AddInternalRef()
  {
    return __k3d_intrinsics__::AtomicIncrement(&m_IntRef);
  }
  int32_t ReleaseInternal()
  {
    auto c = __k3d_intrinsics__::AtomicDecrement(&m_IntRef);
    if (m_IntRef == 0)
    {
      delete this;
    }
    return c;
  }
  int32_t Release()
  {
    auto c = __k3d_intrinsics__::AtomicDecrement(&m_ExtRef);
    if (m_ExtRef == 0)
    {
      ReleaseInternal();
    }
    return c;
  }
  int32_t AddRef()
  {
    return __k3d_intrinsics__::AtomicIncrement(&m_ExtRef);
  }
private:
  int32_t m_IntRef = 1;
  int32_t m_ExtRef = 1;
};
/* Unthread-safe RefCounted*/
template <>
struct RefCounted<false>
{
  RefCounted() {}
  virtual ~RefCounted() {}
  int32_t AddInternalRef()
  {
    m_IntRef++;
    return m_IntRef;
  }
  int32_t ReleaseInternal()
  {
    m_IntRef--;
    int32_t c = m_IntRef;
    if (m_IntRef == 0)
    {
      delete this;
    }
    return c;
  }
  int32_t Release()
  {
    m_ExtRef--;
    int32_t c = m_ExtRef;
    if (m_ExtRef == 0)
    {
      ReleaseInternal();
    }
    return c;
  }
  int32_t AddRef()
  {
    m_ExtRef++;
    return m_ExtRef;
  }
private:
  int32_t m_IntRef = 1;
  int32_t m_ExtRef = 1;
};
template <bool ThreadSafe>
struct NamedObject : public RefCounted<ThreadSafe>
{
  virtual void SetName(const char *) {}
protected:
  void operator delete (void * Ptr)
  {
    __k3d_free__(Ptr, 0);
  }
};
template <class NGFXObj>
class Ptr
{
public:
  explicit Ptr(NGFXObj * pObj)
    : m_Ptr(pObj)
  {}
  Ptr(Ptr<NGFXObj> const& Other)
    : m_Ptr(Other.m_Ptr)
  {
    if(m_Ptr)
      m_Ptr->AddInternalRef();
  }
  Ptr()
    : m_Ptr(nullptr)
  {
  }
  ~Ptr()
  {
    if (m_Ptr)
    {
      m_Ptr->ReleaseInternal();
    }
    m_Ptr = nullptr;
  }
  NGFXObj& operator*() const { return *m_Ptr; }
  NGFXObj* operator->() const { return m_Ptr; }
  explicit operator bool() const
  {
    return m_Ptr != nullptr;
  }
  void Swap(Ptr& Other)
  {
    NGFXObj * const pValue = Other.m_Ptr;
    Other.m_Ptr = m_Ptr;
    m_Ptr = pValue;
  }
  Ptr& operator=(const Ptr& Other)
  {
    typedef Ptr<NGFXObj> ThisType;
    if (&Other != this)
    {
      ThisType(Other).Swap(*this);
    }
    return *this;
  }
  NGFXObj* Get() const
  {
    return m_Ptr;
  }
  NGFXObj** GetAddressOf() const
  {
    return &m_Ptr;
  }
private:
  NGFXObj* m_Ptr;
};

// Result of every call
enum class Result : uint32_t
{
  Ok,
  Failed,
  ParamError,
  DeviceNotFound,
};// Enum Result

enum class PipelineType : uint32_t
{
  Graphics,
  Compute,
};// Enum PipelineType

// Pixel format in storage
enum class PixelFormat : uint32_t
{
  RGBA16Uint,
  RGBA32Float,
  RGBA8UNorm,
  RGBA8UNorm_sRGB,
  R11G11B10Float,
  D32Float,
  RGB32Float,
};// Enum PixelFormat

enum class MultiSampleFlag : uint32_t
{
  MS1x,
  MS2x,
  MS4x,
  MS8x,
  MS16x,
};// Enum MultiSampleFlag

enum class LoadAction : uint32_t
{
  Load,
  Clear,
  DontCare,
};// Enum LoadAction

enum class StoreAction : uint32_t
{
  Store,
  DontCare,
};// Enum StoreAction

enum class VertexFormat : uint32_t
{
  F32C,
  F32C2,
  F32C3,
  F32C4,
};// Enum VertexFormat

enum class PrimitiveType : uint32_t
{
  Points,
  Lines,
  Triangles,
  TriangleStrips,
};// Enum PrimitiveType

enum class BlendOperation : uint32_t
{
  Add,
  Sub,
};// Enum BlendOperation

// Color blending
enum class BlendType : uint32_t
{
  Zero,
  One,
  SrcColor,
  DstColor,
  SrcAlpha,
  DstAlpha,
};// Enum BlendType

enum class StencilOperation : uint32_t
{
  Keep,
  Zero,
  Replace,
  Invert,
  Increment,
  Decrement,
};// Enum StencilOperation

enum class ComparisonFunction : uint32_t
{
  Never,
  Less,
  Equal,
  LessEqual,
  Greater,
  NotEqual,
  GreaterEqual,
  Always,
};// Enum ComparisonFunction

enum class DepthWriteMask : uint32_t
{
  Zero,
  All,
};// Enum DepthWriteMask

enum class ResourceState : uint32_t
{
  Common = 1,
  VertexBuffer = 2,
  ConstantBuffer = 4,
  RenderTarget = 8,
  PixelShaderResource = 16,
  TransferSource = 32,
  TransferDest = 64,
  Present = 128,
  GenericRead = 256,
  UnorderAccess = 512,
};// Enum ResourceState

enum class ResourceViewType : uint32_t
{
  LinearBuffer,
  SampledTexture,
  UnorderAccessTexture,
  UnorderAccessBuffer,
};// Enum ResourceViewType

enum class TextureDimension : uint32_t
{
  Tex1D,
  Tex2D,
  Tex2DMS,
  Tex2DArray,
  Tex3D,
  Tex3DArray,
  TexCube,
};// Enum TextureDimension

enum class FillMode : uint32_t
{
  Wire,
  Solid,
};// Enum FillMode

enum class CullMode : uint32_t
{
  None,
  Front,
  Back,
};// Enum CullMode

enum class FilterMode : uint32_t
{
  Point,
  Linear,
};// Enum FilterMode

enum class AddressMode : uint32_t
{
  Wrap,
  Mirror,
  Clamp,
  Border,
  MirrorOnce,
};// Enum AddressMode

enum class VertexInputRate : uint32_t
{
  PerVertex,
  PerInstance,
};// Enum VertexInputRate

enum class BindingType : uint32_t
{
  UniformBuffer,
  Sampler,
  SampledImage,
  StorageBuffer,
};// Enum BindingType

enum class ShaderStageBit : uint32_t
{
  Vertex = 1,
  Fragment = 2,
  Compute = 4,
  Geometry = 8,
  TessailationEval = 16,
  TessailationControl = 32,
};// Enum ShaderStageBit

enum class ShaderFormat : uint32_t
{
  Text,
  ByteCode,
};// Enum ShaderFormat

enum class ShaderLang : uint32_t
{
  HLSL,
  MetalSL,
  GLSL,
};// Enum ShaderLang

enum class ShaderProfile : uint32_t
{
  SM4,
  SM5,
  SM6,
};// Enum ShaderProfile

enum class ShaderDataType : uint32_t
{
  Bool,
  Bool2,
  Bool3,
  Bool4,
  Int,
  Int2,
  Int3,
  Int4,
  UInt,
  UInt2,
  UInt3,
  UInt4,
  Float,
  Float2,
  Float3,
  Float4,
  Mat2,
  Mat2x3,
  Mat2x4,
  Mat3x2,
  Mat3,
  Mat3x4,
  Mat4x2,
  Mat4,
  Unknown,
};// Enum ShaderDataType

enum class ShaderBindType : uint32_t
{
  Undefined,
  Block,
  Sampler,
  Texture,
  SamplerTexture,
  Buffer,
  Constant,
};// Enum ShaderBindType

enum class CommandQueueType : uint32_t
{
  Graphics,
  Compute,
};// Enum CommandQueueType

// Type of shader
enum class ShaderType : uint32_t
{
  Vertex,
  Fragment,
  Compute,
  Geometry,
  TessailationEval,
  TessailationControl,
};// Enum ShaderType

struct SwapChain;
struct Function;
struct Compiler;
struct Factory;
struct RenderTarget;
struct RenderPass;
struct Pipeline;
struct ComputePipeline;
struct RenderPipeline;
struct PipelineLayout;
struct BindingTable;
struct Sampler;
struct Resource;
struct Buffer;
struct BufferView;
struct Texture;
struct TextureView;
struct Device;
struct Fence;
struct FrameBuffer;
struct CommandQueue;
struct CommandBuffer;
struct CommandEncoder;
struct RenderCommandEncoder;
struct ComputeCommandEncoder;
struct ParallelRenderCommandEncoder;

struct DepthStencilOp
{
  StencilOperation stencilFailOp;
  StencilOperation depthStencilFailOp;
  StencilOperation stencilPassOp;
  ComparisonFunction stencilFunc;

  DepthStencilOp(StencilOperation _stencilFailOp, StencilOperation _depthStencilFailOp, StencilOperation _stencilPassOp, ComparisonFunction _stencilFunc)
  : stencilFailOp(_stencilFailOp)
  , depthStencilFailOp(_depthStencilFailOp)
  , stencilPassOp(_stencilPassOp)
  , stencilFunc(_stencilFunc)
  {}

  DepthStencilOp& SetStencilFailOp(StencilOperation _stencilFailOp)
  {
    stencilFailOp = _stencilFailOp;
    return *this;
  }

  DepthStencilOp& SetDepthStencilFailOp(StencilOperation _depthStencilFailOp)
  {
    depthStencilFailOp = _depthStencilFailOp;
    return *this;
  }

  DepthStencilOp& SetStencilPassOp(StencilOperation _stencilPassOp)
  {
    stencilPassOp = _stencilPassOp;
    return *this;
  }

  DepthStencilOp& SetStencilFunc(ComparisonFunction _stencilFunc)
  {
    stencilFunc = _stencilFunc;
    return *this;
  }
};

static_assert(sizeof(DepthStencilOp) == sizeof(ngfxDepthStencilOp), "DepthStencilOp & ngfxDepthStencilOp Size Not Equal!");

struct RasterizerState
{
  FillMode fillMode;
  CullMode cullMode;
  Bool32 frontCCW;
  int32_t depthBias;
  Bool32 multiSampleEnable;

  RasterizerState(FillMode _fillMode, CullMode _cullMode, Bool32 _frontCCW, int32_t _depthBias, Bool32 _multiSampleEnable)
  : fillMode(_fillMode)
  , cullMode(_cullMode)
  , frontCCW(_frontCCW)
  , depthBias(_depthBias)
  , multiSampleEnable(_multiSampleEnable)
  {}

  RasterizerState& SetFillMode(FillMode _fillMode)
  {
    fillMode = _fillMode;
    return *this;
  }

  RasterizerState& SetCullMode(CullMode _cullMode)
  {
    cullMode = _cullMode;
    return *this;
  }

  RasterizerState& SetFrontCCW(Bool32 _frontCCW)
  {
    frontCCW = _frontCCW;
    return *this;
  }

  RasterizerState& SetDepthBias(int32_t _depthBias)
  {
    depthBias = _depthBias;
    return *this;
  }

  RasterizerState& SetMultiSampleEnable(Bool32 _multiSampleEnable)
  {
    multiSampleEnable = _multiSampleEnable;
    return *this;
  }
};

static_assert(sizeof(RasterizerState) == sizeof(ngfxRasterizerState), "RasterizerState & ngfxRasterizerState Size Not Equal!");

struct BlendState
{
  Bool32 enable;
  BlendType srcColorBlend;
  BlendType destColorBlend;
  BlendOperation colorBlendOp;
  BlendType srcAlphaBlend;
  BlendType destAlphaBlend;
  BlendOperation alphaBlendOp;
  uint32_t colorWriteMask;

  BlendState(Bool32 _enable, BlendType _srcColorBlend, BlendType _destColorBlend, BlendOperation _colorBlendOp, BlendType _srcAlphaBlend, BlendType _destAlphaBlend, BlendOperation _alphaBlendOp, uint32_t _colorWriteMask)
  : enable(_enable)
  , srcColorBlend(_srcColorBlend)
  , destColorBlend(_destColorBlend)
  , colorBlendOp(_colorBlendOp)
  , srcAlphaBlend(_srcAlphaBlend)
  , destAlphaBlend(_destAlphaBlend)
  , alphaBlendOp(_alphaBlendOp)
  , colorWriteMask(_colorWriteMask)
  {}

  BlendState& SetEnable(Bool32 _enable)
  {
    enable = _enable;
    return *this;
  }

  BlendState& SetSrcColorBlend(BlendType _srcColorBlend)
  {
    srcColorBlend = _srcColorBlend;
    return *this;
  }

  BlendState& SetDestColorBlend(BlendType _destColorBlend)
  {
    destColorBlend = _destColorBlend;
    return *this;
  }

  BlendState& SetColorBlendOp(BlendOperation _colorBlendOp)
  {
    colorBlendOp = _colorBlendOp;
    return *this;
  }

  BlendState& SetSrcAlphaBlend(BlendType _srcAlphaBlend)
  {
    srcAlphaBlend = _srcAlphaBlend;
    return *this;
  }

  BlendState& SetDestAlphaBlend(BlendType _destAlphaBlend)
  {
    destAlphaBlend = _destAlphaBlend;
    return *this;
  }

  BlendState& SetAlphaBlendOp(BlendOperation _alphaBlendOp)
  {
    alphaBlendOp = _alphaBlendOp;
    return *this;
  }

  BlendState& SetColorWriteMask(uint32_t _colorWriteMask)
  {
    colorWriteMask = _colorWriteMask;
    return *this;
  }
};

static_assert(sizeof(BlendState) == sizeof(ngfxBlendState), "BlendState & ngfxBlendState Size Not Equal!");

struct DepthStencilState
{
  Bool32 depthEnable;
  DepthWriteMask depthWriteMask;
  ComparisonFunction depthFunc;
  Bool32 stencilEnable;
  DepthStencilOp frontFace;
  DepthStencilOp backFace;

  DepthStencilState(Bool32 _depthEnable, DepthWriteMask _depthWriteMask, ComparisonFunction _depthFunc, Bool32 _stencilEnable, DepthStencilOp _frontFace, DepthStencilOp _backFace)
  : depthEnable(_depthEnable)
  , depthWriteMask(_depthWriteMask)
  , depthFunc(_depthFunc)
  , stencilEnable(_stencilEnable)
  , frontFace(_frontFace)
  , backFace(_backFace)
  {}

  DepthStencilState& SetDepthEnable(Bool32 _depthEnable)
  {
    depthEnable = _depthEnable;
    return *this;
  }

  DepthStencilState& SetDepthWriteMask(DepthWriteMask _depthWriteMask)
  {
    depthWriteMask = _depthWriteMask;
    return *this;
  }

  DepthStencilState& SetDepthFunc(ComparisonFunction _depthFunc)
  {
    depthFunc = _depthFunc;
    return *this;
  }

  DepthStencilState& SetStencilEnable(Bool32 _stencilEnable)
  {
    stencilEnable = _stencilEnable;
    return *this;
  }

  DepthStencilState& SetFrontFace(DepthStencilOp _frontFace)
  {
    frontFace = _frontFace;
    return *this;
  }

  DepthStencilState& SetBackFace(DepthStencilOp _backFace)
  {
    backFace = _backFace;
    return *this;
  }
};

static_assert(sizeof(DepthStencilState) == sizeof(ngfxDepthStencilState), "DepthStencilState & ngfxDepthStencilState Size Not Equal!");

struct DeviceDesc
{
  uint64_t maxAllocation;
  char * vendorName;

  DeviceDesc(uint64_t _maxAllocation, char * _vendorName)
  : maxAllocation(_maxAllocation)
  , vendorName(_vendorName)
  {}

  DeviceDesc& SetMaxAllocation(uint64_t _maxAllocation)
  {
    maxAllocation = _maxAllocation;
    return *this;
  }

  DeviceDesc& SetVendorName(char * _vendorName)
  {
    vendorName = _vendorName;
    return *this;
  }
};

static_assert(sizeof(DeviceDesc) == sizeof(ngfxDeviceDesc), "DeviceDesc & ngfxDeviceDesc Size Not Equal!");

struct Filter
{
  FilterMode minFilter;
  FilterMode magFilter;
  FilterMode mipMapFilter;

  Filter(FilterMode _minFilter, FilterMode _magFilter, FilterMode _mipMapFilter)
  : minFilter(_minFilter)
  , magFilter(_magFilter)
  , mipMapFilter(_mipMapFilter)
  {}

  Filter& SetMinFilter(FilterMode _minFilter)
  {
    minFilter = _minFilter;
    return *this;
  }

  Filter& SetMagFilter(FilterMode _magFilter)
  {
    magFilter = _magFilter;
    return *this;
  }

  Filter& SetMipMapFilter(FilterMode _mipMapFilter)
  {
    mipMapFilter = _mipMapFilter;
    return *this;
  }
};

static_assert(sizeof(Filter) == sizeof(ngfxFilter), "Filter & ngfxFilter Size Not Equal!");

// Description of sampler
struct SamplerDesc
{
  Filter filter;
  AddressMode U,V,W;
  Float32 mipLodBias;
  uint32_t maxAnistropy;
  ComparisonFunction comparisonFunc;
  Float32 minLod;
  Float32 maxLod;

  SamplerDesc(Filter _filter, AddressMode _U, AddressMode _V, AddressMode _W, Float32 _mipLodBias, uint32_t _maxAnistropy, ComparisonFunction _comparisonFunc, Float32 _minLod, Float32 _maxLod)
  : filter(_filter)
  , U(_U)
  , V(_V)
  , W(_W)
  , mipLodBias(_mipLodBias)
  , maxAnistropy(_maxAnistropy)
  , comparisonFunc(_comparisonFunc)
  , minLod(_minLod)
  , maxLod(_maxLod)
  {}

  SamplerDesc& SetFilter(Filter _filter)
  {
    filter = _filter;
    return *this;
  }

  SamplerDesc& SetUVW(AddressMode _U, AddressMode _V, AddressMode _W)
  {
    U = _U;
    V = _V;
    W = _W;
    return *this;
  }

  SamplerDesc& SetMipLodBias(Float32 _mipLodBias)
  {
    mipLodBias = _mipLodBias;
    return *this;
  }

  SamplerDesc& SetMaxAnistropy(uint32_t _maxAnistropy)
  {
    maxAnistropy = _maxAnistropy;
    return *this;
  }

  SamplerDesc& SetComparisonFunc(ComparisonFunction _comparisonFunc)
  {
    comparisonFunc = _comparisonFunc;
    return *this;
  }

  SamplerDesc& SetMinLod(Float32 _minLod)
  {
    minLod = _minLod;
    return *this;
  }

  SamplerDesc& SetMaxLod(Float32 _maxLod)
  {
    maxLod = _maxLod;
    return *this;
  }
};

static_assert(sizeof(SamplerDesc) == sizeof(ngfxSamplerDesc), "SamplerDesc & ngfxSamplerDesc Size Not Equal!");

// Description of a buffer
struct BufferDesc
{
  uint64_t size;

  BufferDesc(uint64_t _size)
  : size(_size)
  {}

  BufferDesc& SetSize(uint64_t _size)
  {
    size = _size;
    return *this;
  }
};

static_assert(sizeof(BufferDesc) == sizeof(ngfxBufferDesc), "BufferDesc & ngfxBufferDesc Size Not Equal!");

// Description of the buffer usage
struct BufferViewDesc
{
  ResourceViewType view;
  ResourceState state;
  uint64_t size;
  uint64_t offset;
  uint64_t stride;

  BufferViewDesc(ResourceViewType _view, ResourceState _state, uint64_t _size, uint64_t _offset, uint64_t _stride)
  : view(_view)
  , state(_state)
  , size(_size)
  , offset(_offset)
  , stride(_stride)
  {}

  BufferViewDesc& SetView(ResourceViewType _view)
  {
    view = _view;
    return *this;
  }

  BufferViewDesc& SetState(ResourceState _state)
  {
    state = _state;
    return *this;
  }

  BufferViewDesc& SetSize(uint64_t _size)
  {
    size = _size;
    return *this;
  }

  BufferViewDesc& SetOffset(uint64_t _offset)
  {
    offset = _offset;
    return *this;
  }

  BufferViewDesc& SetStride(uint64_t _stride)
  {
    stride = _stride;
    return *this;
  }
};

static_assert(sizeof(BufferViewDesc) == sizeof(ngfxBufferViewDesc), "BufferViewDesc & ngfxBufferViewDesc Size Not Equal!");

// Description of a texture
struct TextureDesc
{
  PixelFormat format;
  uint32_t width;
  uint32_t height;
  uint32_t depth;
  uint32_t layers;
  uint32_t mipLevels;

  TextureDesc(PixelFormat _format, uint32_t _width, uint32_t _height, uint32_t _depth, uint32_t _layers, uint32_t _mipLevels)
  : format(_format)
  , width(_width)
  , height(_height)
  , depth(_depth)
  , layers(_layers)
  , mipLevels(_mipLevels)
  {}

  TextureDesc& SetFormat(PixelFormat _format)
  {
    format = _format;
    return *this;
  }

  TextureDesc& SetWidth(uint32_t _width)
  {
    width = _width;
    return *this;
  }

  TextureDesc& SetHeight(uint32_t _height)
  {
    height = _height;
    return *this;
  }

  TextureDesc& SetDepth(uint32_t _depth)
  {
    depth = _depth;
    return *this;
  }

  TextureDesc& SetLayers(uint32_t _layers)
  {
    layers = _layers;
    return *this;
  }

  TextureDesc& SetMipLevels(uint32_t _mipLevels)
  {
    mipLevels = _mipLevels;
    return *this;
  }
};

static_assert(sizeof(TextureDesc) == sizeof(ngfxTextureDesc), "TextureDesc & ngfxTextureDesc Size Not Equal!");

// Description about how the texture be used
struct TextureViewDesc
{
  ResourceViewType view;
  ResourceState state;
  TextureDimension dimension;
  uint32_t mipLevel;

  TextureViewDesc(ResourceViewType _view, ResourceState _state, TextureDimension _dimension, uint32_t _mipLevel)
  : view(_view)
  , state(_state)
  , dimension(_dimension)
  , mipLevel(_mipLevel)
  {}

  TextureViewDesc& SetView(ResourceViewType _view)
  {
    view = _view;
    return *this;
  }

  TextureViewDesc& SetState(ResourceState _state)
  {
    state = _state;
    return *this;
  }

  TextureViewDesc& SetDimension(TextureDimension _dimension)
  {
    dimension = _dimension;
    return *this;
  }

  TextureViewDesc& SetMipLevel(uint32_t _mipLevel)
  {
    mipLevel = _mipLevel;
    return *this;
  }
};

static_assert(sizeof(TextureViewDesc) == sizeof(ngfxTextureViewDesc), "TextureViewDesc & ngfxTextureViewDesc Size Not Equal!");

struct VertexLayout
{
  VertexInputRate rate;
  uint32_t stride;

  VertexLayout(VertexInputRate _rate, uint32_t _stride)
  : rate(_rate)
  , stride(_stride)
  {}

  VertexLayout& SetRate(VertexInputRate _rate)
  {
    rate = _rate;
    return *this;
  }

  VertexLayout& SetStride(uint32_t _stride)
  {
    stride = _stride;
    return *this;
  }
};

static_assert(sizeof(VertexLayout) == sizeof(ngfxVertexLayout), "VertexLayout & ngfxVertexLayout Size Not Equal!");

struct VertexAttribute
{
  VertexFormat format;
  uint32_t offset;
  uint32_t slot;

  VertexAttribute(VertexFormat _format, uint32_t _offset, uint32_t _slot)
  : format(_format)
  , offset(_offset)
  , slot(_slot)
  {}

  VertexAttribute& SetFormat(VertexFormat _format)
  {
    format = _format;
    return *this;
  }

  VertexAttribute& SetOffset(uint32_t _offset)
  {
    offset = _offset;
    return *this;
  }

  VertexAttribute& SetSlot(uint32_t _slot)
  {
    slot = _slot;
    return *this;
  }
};

static_assert(sizeof(VertexAttribute) == sizeof(ngfxVertexAttribute), "VertexAttribute & ngfxVertexAttribute Size Not Equal!");

// Vertex input description
struct VertexInputState
{
  const VertexAttribute * pAttributes;
  uint32_t attributeCount;
  const VertexLayout * pLayouts;
  uint32_t layoutCount;

  VertexInputState(const VertexAttribute * _pAttributes, uint32_t _attributeCount, const VertexLayout * _pLayouts, uint32_t _layoutCount)
  : pAttributes(_pAttributes)
  , attributeCount(_attributeCount)
  , pLayouts(_pLayouts)
  , layoutCount(_layoutCount)
  {}

  VertexInputState& SetPAttributes(const VertexAttribute * _pAttributes)
  {
    pAttributes = _pAttributes;
    return *this;
  }

  VertexInputState& SetAttributeCount(uint32_t _attributeCount)
  {
    attributeCount = _attributeCount;
    return *this;
  }

  VertexInputState& SetPLayouts(const VertexLayout * _pLayouts)
  {
    pLayouts = _pLayouts;
    return *this;
  }

  VertexInputState& SetLayoutCount(uint32_t _layoutCount)
  {
    layoutCount = _layoutCount;
    return *this;
  }
};

static_assert(sizeof(VertexInputState) == sizeof(ngfxVertexInputState), "VertexInputState & ngfxVertexInputState Size Not Equal!");

// Description of rendering pipeline
struct RenderPipelineDesc
{
  RasterizerState rasterState;
  BlendState blendState;
  DepthStencilState depthStencil;
  VertexInputState inputState;
  PrimitiveType primitiveTopology;
  Function * vertexFunction;
  Function * pixelFunction;

  RenderPipelineDesc(RasterizerState _rasterState, BlendState _blendState, DepthStencilState _depthStencil, VertexInputState _inputState, PrimitiveType _primitiveTopology, Function * _vertexFunction, Function * _pixelFunction)
  : rasterState(_rasterState)
  , blendState(_blendState)
  , depthStencil(_depthStencil)
  , inputState(_inputState)
  , primitiveTopology(_primitiveTopology)
  , vertexFunction(_vertexFunction)
  , pixelFunction(_pixelFunction)
  {}

  RenderPipelineDesc& SetRasterState(RasterizerState _rasterState)
  {
    rasterState = _rasterState;
    return *this;
  }

  RenderPipelineDesc& SetBlendState(BlendState _blendState)
  {
    blendState = _blendState;
    return *this;
  }

  RenderPipelineDesc& SetDepthStencil(DepthStencilState _depthStencil)
  {
    depthStencil = _depthStencil;
    return *this;
  }

  RenderPipelineDesc& SetInputState(VertexInputState _inputState)
  {
    inputState = _inputState;
    return *this;
  }

  RenderPipelineDesc& SetPrimitiveTopology(PrimitiveType _primitiveTopology)
  {
    primitiveTopology = _primitiveTopology;
    return *this;
  }

  RenderPipelineDesc& SetVertexFunction(Function * _vertexFunction)
  {
    vertexFunction = _vertexFunction;
    return *this;
  }

  RenderPipelineDesc& SetPixelFunction(Function * _pixelFunction)
  {
    pixelFunction = _pixelFunction;
    return *this;
  }
};

static_assert(sizeof(RenderPipelineDesc) == sizeof(ngfxRenderPipelineDesc), "RenderPipelineDesc & ngfxRenderPipelineDesc Size Not Equal!");

// Description of Pipeline Layout (How to layout bindings)
struct PipelineLayoutDesc
{
  ShaderStageBit visibility;
  BindingType bindingType;
  uint32_t slot;
  uint32_t count;

  PipelineLayoutDesc(ShaderStageBit _visibility, BindingType _bindingType, uint32_t _slot, uint32_t _count)
  : visibility(_visibility)
  , bindingType(_bindingType)
  , slot(_slot)
  , count(_count)
  {}

  PipelineLayoutDesc& SetVisibility(ShaderStageBit _visibility)
  {
    visibility = _visibility;
    return *this;
  }

  PipelineLayoutDesc& SetBindingType(BindingType _bindingType)
  {
    bindingType = _bindingType;
    return *this;
  }

  PipelineLayoutDesc& SetSlot(uint32_t _slot)
  {
    slot = _slot;
    return *this;
  }

  PipelineLayoutDesc& SetCount(uint32_t _count)
  {
    count = _count;
    return *this;
  }
};

static_assert(sizeof(PipelineLayoutDesc) == sizeof(ngfxPipelineLayoutDesc), "PipelineLayoutDesc & ngfxPipelineLayoutDesc Size Not Equal!");

struct AttachmentDesc
{
  LoadAction loadAction;
  StoreAction storeAction;
  Texture * texture;

  AttachmentDesc(LoadAction _loadAction, StoreAction _storeAction, Texture * _texture)
  : loadAction(_loadAction)
  , storeAction(_storeAction)
  , texture(_texture)
  {}

  AttachmentDesc& SetLoadAction(LoadAction _loadAction)
  {
    loadAction = _loadAction;
    return *this;
  }

  AttachmentDesc& SetStoreAction(StoreAction _storeAction)
  {
    storeAction = _storeAction;
    return *this;
  }

  AttachmentDesc& SetTexture(Texture * _texture)
  {
    texture = _texture;
    return *this;
  }
};

static_assert(sizeof(AttachmentDesc) == sizeof(ngfxAttachmentDesc), "AttachmentDesc & ngfxAttachmentDesc Size Not Equal!");

struct ColorAttachmentDesc
{
  Float32x4 clearColor;

  ColorAttachmentDesc(Float32x4 _clearColor)
  : clearColor(_clearColor)
  {}

  ColorAttachmentDesc& SetClearColor(Float32x4 _clearColor)
  {
    clearColor = _clearColor;
    return *this;
  }
};

static_assert(sizeof(ColorAttachmentDesc) == sizeof(ngfxColorAttachmentDesc), "ColorAttachmentDesc & ngfxColorAttachmentDesc Size Not Equal!");

struct DepthStencilAttachmentDesc
{
  Float32 clearDepth;
  int32_t clearStencil;

  DepthStencilAttachmentDesc(Float32 _clearDepth, int32_t _clearStencil)
  : clearDepth(_clearDepth)
  , clearStencil(_clearStencil)
  {}

  DepthStencilAttachmentDesc& SetClearDepth(Float32 _clearDepth)
  {
    clearDepth = _clearDepth;
    return *this;
  }

  DepthStencilAttachmentDesc& SetClearStencil(int32_t _clearStencil)
  {
    clearStencil = _clearStencil;
    return *this;
  }
};

static_assert(sizeof(DepthStencilAttachmentDesc) == sizeof(ngfxDepthStencilAttachmentDesc), "DepthStencilAttachmentDesc & ngfxDepthStencilAttachmentDesc Size Not Equal!");

// Description of Render Pass
struct RenderPassDesc
{
  ColorAttachmentDesc * pColorAttachments;
  int32_t colorAttachmentsCount;
  DepthStencilAttachmentDesc * pDepthStencilAttachment;

  RenderPassDesc(ColorAttachmentDesc * _pColorAttachments, int32_t _colorAttachmentsCount, DepthStencilAttachmentDesc * _pDepthStencilAttachment)
  : pColorAttachments(_pColorAttachments)
  , colorAttachmentsCount(_colorAttachmentsCount)
  , pDepthStencilAttachment(_pDepthStencilAttachment)
  {}

  RenderPassDesc& SetPColorAttachments(ColorAttachmentDesc * _pColorAttachments)
  {
    pColorAttachments = _pColorAttachments;
    return *this;
  }

  RenderPassDesc& SetColorAttachmentsCount(int32_t _colorAttachmentsCount)
  {
    colorAttachmentsCount = _colorAttachmentsCount;
    return *this;
  }

  RenderPassDesc& SetPDepthStencilAttachment(DepthStencilAttachmentDesc * _pDepthStencilAttachment)
  {
    pDepthStencilAttachment = _pDepthStencilAttachment;
    return *this;
  }
};

static_assert(sizeof(RenderPassDesc) == sizeof(ngfxRenderPassDesc), "RenderPassDesc & ngfxRenderPassDesc Size Not Equal!");

// Description of Render Target
struct RenderTargetDesc
{
  int32_t XX;

  RenderTargetDesc(int32_t _XX)
  : XX(_XX)
  {}

  RenderTargetDesc& SetXX(int32_t _XX)
  {
    XX = _XX;
    return *this;
  }
};

static_assert(sizeof(RenderTargetDesc) == sizeof(ngfxRenderTargetDesc), "RenderTargetDesc & ngfxRenderTargetDesc Size Not Equal!");

struct DrawIndexedInstancedDesc
{
  uint32_t indexCountPerInstance;
  uint32_t instanceCount;
  uint32_t startId;
  uint32_t baseVertexId;
  uint32_t startInstanceId;

  DrawIndexedInstancedDesc(uint32_t _indexCountPerInstance, uint32_t _instanceCount, uint32_t _startId, uint32_t _baseVertexId, uint32_t _startInstanceId)
  : indexCountPerInstance(_indexCountPerInstance)
  , instanceCount(_instanceCount)
  , startId(_startId)
  , baseVertexId(_baseVertexId)
  , startInstanceId(_startInstanceId)
  {}

  DrawIndexedInstancedDesc& SetIndexCountPerInstance(uint32_t _indexCountPerInstance)
  {
    indexCountPerInstance = _indexCountPerInstance;
    return *this;
  }

  DrawIndexedInstancedDesc& SetInstanceCount(uint32_t _instanceCount)
  {
    instanceCount = _instanceCount;
    return *this;
  }

  DrawIndexedInstancedDesc& SetStartId(uint32_t _startId)
  {
    startId = _startId;
    return *this;
  }

  DrawIndexedInstancedDesc& SetBaseVertexId(uint32_t _baseVertexId)
  {
    baseVertexId = _baseVertexId;
    return *this;
  }

  DrawIndexedInstancedDesc& SetStartInstanceId(uint32_t _startInstanceId)
  {
    startInstanceId = _startInstanceId;
    return *this;
  }
};

static_assert(sizeof(DrawIndexedInstancedDesc) == sizeof(ngfxDrawIndexedInstancedDesc), "DrawIndexedInstancedDesc & ngfxDrawIndexedInstancedDesc Size Not Equal!");

struct DrawInstancedDesc
{
  uint32_t vertexCountPerInstance;
  uint32_t instanceCount;
  uint32_t startVertexId;
  uint32_t startInstanceId;

  DrawInstancedDesc(uint32_t _vertexCountPerInstance, uint32_t _instanceCount, uint32_t _startVertexId, uint32_t _startInstanceId)
  : vertexCountPerInstance(_vertexCountPerInstance)
  , instanceCount(_instanceCount)
  , startVertexId(_startVertexId)
  , startInstanceId(_startInstanceId)
  {}

  DrawInstancedDesc& SetVertexCountPerInstance(uint32_t _vertexCountPerInstance)
  {
    vertexCountPerInstance = _vertexCountPerInstance;
    return *this;
  }

  DrawInstancedDesc& SetInstanceCount(uint32_t _instanceCount)
  {
    instanceCount = _instanceCount;
    return *this;
  }

  DrawInstancedDesc& SetStartVertexId(uint32_t _startVertexId)
  {
    startVertexId = _startVertexId;
    return *this;
  }

  DrawInstancedDesc& SetStartInstanceId(uint32_t _startInstanceId)
  {
    startInstanceId = _startInstanceId;
    return *this;
  }
};

static_assert(sizeof(DrawInstancedDesc) == sizeof(ngfxDrawInstancedDesc), "DrawInstancedDesc & ngfxDrawInstancedDesc Size Not Equal!");

struct Viewport
{
  Float32 left, top;
  Float32 width, height;
  Float32 minDepth;
  Float32 maxDepth;

  Viewport(Float32 _left, Float32 _top, Float32 _width, Float32 _height, Float32 _minDepth, Float32 _maxDepth)
  : left(_left)
  , top(_top)
  , width(_width)
  , height(_height)
  , minDepth(_minDepth)
  , maxDepth(_maxDepth)
  {}

  Viewport& SetLeftTop(Float32 _left, Float32 _top)
  {
    left = _left;
    top = _top;
    return *this;
  }

  Viewport& SetWidthHeight(Float32 _width, Float32 _height)
  {
    width = _width;
    height = _height;
    return *this;
  }

  Viewport& SetMinDepth(Float32 _minDepth)
  {
    minDepth = _minDepth;
    return *this;
  }

  Viewport& SetMaxDepth(Float32 _maxDepth)
  {
    maxDepth = _maxDepth;
    return *this;
  }
};

static_assert(sizeof(Viewport) == sizeof(ngfxViewport), "Viewport & ngfxViewport Size Not Equal!");

struct SwapChainDesc
{
  PixelFormat pixelFormat;
  uint32_t width;
  uint32_t height;
  uint32_t numColorBuffers;
  Bool32 hasDepthStencilTarget;
  PixelFormat depthStencilFormat;

  SwapChainDesc(PixelFormat _pixelFormat, uint32_t _width, uint32_t _height, uint32_t _numColorBuffers, Bool32 _hasDepthStencilTarget, PixelFormat _depthStencilFormat)
  : pixelFormat(_pixelFormat)
  , width(_width)
  , height(_height)
  , numColorBuffers(_numColorBuffers)
  , hasDepthStencilTarget(_hasDepthStencilTarget)
  , depthStencilFormat(_depthStencilFormat)
  {}

  SwapChainDesc& SetPixelFormat(PixelFormat _pixelFormat)
  {
    pixelFormat = _pixelFormat;
    return *this;
  }

  SwapChainDesc& SetWidth(uint32_t _width)
  {
    width = _width;
    return *this;
  }

  SwapChainDesc& SetHeight(uint32_t _height)
  {
    height = _height;
    return *this;
  }

  SwapChainDesc& SetNumColorBuffers(uint32_t _numColorBuffers)
  {
    numColorBuffers = _numColorBuffers;
    return *this;
  }

  SwapChainDesc& SetHasDepthStencilTarget(Bool32 _hasDepthStencilTarget)
  {
    hasDepthStencilTarget = _hasDepthStencilTarget;
    return *this;
  }

  SwapChainDesc& SetDepthStencilFormat(PixelFormat _depthStencilFormat)
  {
    depthStencilFormat = _depthStencilFormat;
    return *this;
  }
};

static_assert(sizeof(SwapChainDesc) == sizeof(ngfxSwapChainDesc), "SwapChainDesc & ngfxSwapChainDesc Size Not Equal!");

struct ShaderOption
{
  const char * entryName;
  ShaderProfile profile;
  ShaderFormat format;

  ShaderOption(const char * _entryName, ShaderProfile _profile, ShaderFormat _format)
  : entryName(_entryName)
  , profile(_profile)
  , format(_format)
  {}

  ShaderOption& SetEntryName(const char * _entryName)
  {
    entryName = _entryName;
    return *this;
  }

  ShaderOption& SetProfile(ShaderProfile _profile)
  {
    profile = _profile;
    return *this;
  }

  ShaderOption& SetFormat(ShaderFormat _format)
  {
    format = _format;
    return *this;
  }
};

static_assert(sizeof(ShaderOption) == sizeof(ngfxShaderOption), "ShaderOption & ngfxShaderOption Size Not Equal!");

// Present drawables
struct SwapChain : public NamedObject<false>
{
  virtual Result GetTexture(Texture ** ppTexture, uint32_t index) = 0;
  virtual void Present() = 0;
};

struct Function : public RefCounted<false>
{
  virtual ShaderType Type() = 0;
  virtual const char * Name() = 0;
};

struct Compiler : public RefCounted<false>
{
  virtual Result Compile(const ShaderOption * option, void * pData, uint32_t size, Function ** output) = 0;
  virtual Result Reflect(void * pData, uint32_t size) = 0;
};

// Create devices and swapchains
struct Factory : public NamedObject<false>
{
  virtual Result EnumDevice(uint32_t * count, Device ** ppDevice) = 0;
  virtual Result CreateSwapchain(const SwapChainDesc * desc, CommandQueue * pCommandQueue, void * pWindow, SwapChain ** pSwapchain) = 0;
  virtual Result CreateCompiler(ShaderLang shaderLang, Compiler ** compiler) = 0;
};

struct RenderTarget : public NamedObject<false>
{
};

struct RenderPass : public NamedObject<false>
{
};

struct Pipeline : public NamedObject<false>
{
  virtual PipelineType Type() = 0;
};

struct ComputePipeline : public Pipeline
{
};

struct RenderPipeline : public Pipeline
{
  virtual Result GetDesc(RenderPipelineDesc * pDesc) = 0;
};

struct PipelineLayout : public NamedObject<false>
{
  virtual Result CreateBindingTable(BindingTable ** ppBindingTable) = 0;
};

// Shader binding table
struct BindingTable : public NamedObject<true>
{
  virtual void SetSampler(uint32_t index, ShaderType shaderVis, Sampler * pSampler) = 0;
  virtual void SetBuffer(uint32_t index, ShaderType shaderVis, BufferView * bufferView) = 0;
  virtual void SetTexture(uint32_t index, ShaderType shaderVis, TextureView * textureView) = 0;
};

struct Sampler : public NamedObject<true>
{
  virtual Result GetDesc(SamplerDesc * desc) = 0;
};

struct Resource : public NamedObject<true>
{
  virtual void * Map(uint64_t offset, uint64_t size) = 0;
  virtual void UnMap() = 0;
};

struct Buffer : public Resource
{
  virtual Result GetDesc(BufferDesc * pDesc) = 0;
};

struct BufferView : public NamedObject<false>
{
};

struct Texture : public Resource
{
  virtual Result GetDesc(TextureDesc * pDesc) = 0;
};

struct TextureView : public NamedObject<false>
{
};

// Gpu device
struct Device : public NamedObject<true>
{
  virtual void GetDesc(DeviceDesc * pDesc) = 0;
  virtual Result CreateCommandQueue(CommandQueueType queueType, CommandQueue ** pQueue) = 0;
  virtual Result CreatePipelineLayout(const PipelineLayoutDesc * pPipelineLayoutDesc, PipelineLayout ** ppPipelineLayout) = 0;
  virtual Result CreateBindingTable(PipelineLayout * pPipelineLayout, BindingTable ** ppBindingTable) = 0;
  virtual Result CreateRenderPipeline(const RenderPipelineDesc * pPipelineDesc, PipelineLayout * pPipelineLayout, RenderPass * pRenderPass, Pipeline ** pPipelineState) = 0;
  virtual Result CreateComputePipeline(Function * pComputeFunction, PipelineLayout * pPipelineLayout, Pipeline ** pPipeline) = 0;
  virtual Result CreateRenderPass(const RenderPassDesc * desc, RenderPass ** ppRenderpass) = 0;
  virtual Result CreateRenderTarget(const RenderTargetDesc * desc, RenderTarget ** ppRenderTarget) = 0;
  virtual Result CreateSampler(const SamplerDesc* desc, Sampler ** pSampler) = 0;
  virtual Result CreateBuffer(const BufferDesc* desc, Buffer ** pBuffer) = 0;
  virtual Result CreateBufferView(const BufferViewDesc * desc, Buffer * pBuffer, BufferView ** pBufView) = 0;
  virtual Result CreateTexture(const TextureDesc * desc, Texture ** pTexture) = 0;
  virtual Result CreateTextureView(const TextureViewDesc * desc, Texture * pTexture, TextureView ** pTexView) = 0;
  virtual void WaitIdle() = 0;
};

struct Fence : public NamedObject<false>
{
  virtual void Wait() = 0;
  virtual void Reset() = 0;
};

struct FrameBuffer : public NamedObject<false>
{
};

struct CommandQueue : public NamedObject<true>
{
  virtual CommandBuffer * CommandBuffer() = 0;
};

// Gpu Command Buffer
struct CommandBuffer : public NamedObject<true>
{
  virtual void Commit(Fence * pFence) = 0;
  virtual RenderCommandEncoder * RenderCommandEncoder() = 0;
  virtual ComputeCommandEncoder * ComputeCommandEncoder() = 0;
  virtual ParallelRenderCommandEncoder * ParallelCommandEncoder() = 0;
};

struct CommandEncoder : public NamedObject<true>
{
  virtual void CopyTexture() = 0;
  virtual void CopyBuffer() = 0;
  virtual void SetPipeline(Pipeline* pPipelineState) = 0;
  virtual void SetPipelineLayout(PipelineLayout * pPipelineLayout) = 0;
  virtual void SetBindingTable(BindingTable * pBindingTable) = 0;
  virtual void EndEncode() = 0;
};

// Render Command Encoder
struct RenderCommandEncoder : public CommandEncoder
{
  virtual void SetScissorRect(uint32_t x, uint32_t y, uint32_t w, uint32_t h) = 0;
  virtual void SetViewport(const Viewport * pViewport) = 0;
  virtual void SetIndexBuffer(Buffer * pIndexBuffer) = 0;
  virtual void SetVertexBuffer(uint32_t slot, uint64_t offset, Buffer * pVertexBuffer) = 0;
  virtual void SetPrimitiveType(PrimitiveType primitive) = 0;
  virtual void DrawInstanced(const DrawInstancedDesc * drawParam) = 0;
  virtual void DrawIndexedInstanced(const DrawIndexedInstancedDesc * drawParam) = 0;
  virtual void Present(SwapChain * pSwapChain) = 0;
};

struct ComputeCommandEncoder : public CommandEncoder
{
  virtual void Dispatch(uint32_t x, uint32_t y, uint32_t z) = 0;
};

struct ParallelRenderCommandEncoder : public CommandEncoder
{
  virtual RenderCommandEncoder * Encoder() = 0;
};

} // namespace ngfx
#endif // __cplusplus

#endif // __NGFX__

uniform sampler2D		InputTex;
uniform sampler2D		PositionTex;
uniform sampler2D		NormalTex;
uniform sampler2D		RotationTex;

uniform vec2			Direction;
uniform mat4			ViewMatrix;
uniform float			SigmaScreen;
uniform float			SigmaDepth;
uniform int				nTaps;

uniform float			Near;
uniform float			Beta;
uniform float			Epsilon;
uniform float			Kappa;
uniform float			Sigma;
uniform float			Radius;
uniform int				nSamples;
uniform vec2			Samples[32];

float GaussianWeight(float _s, float _sigma)
{
	float twoSigma2 = 2.f * _sigma * _sigma;
	float factor = 1.f / sqrt(3.141592654f * twoSigma2);
	return factor * exp(-(_s * _s) / twoSigma2);
}

shader SSAOVS(in vec2 Pos:0)
{
	gl_Position = vec4(Pos, 0, 1);
}

shader SSAOBlurPS(out vec4 FragColor:0)
{
	// per pixel shading
	vec2 rcpSize = 1.f / vec2(textureSize(InputTex,0).xy);
	vec2 pix 	 = gl_FragCoord.xy * rcpSize;
	vec4  dref	 = ViewMatrix * vec4(textureLod(PositionTex,pix,0).xyz,1);
	float cref	 = textureLod(InputTex, pix, 0).x;

	// We average the alpha channel since we use it for blending SSAO
	float color  = 0;
	float totalW = 0;
	for(int i=-nTaps;i<=nTaps;++i)
	{
		vec2  p	 = (gl_FragCoord.xy + i*Direction) * rcpSize;
		vec4  d	 = ViewMatrix * vec4(textureLod(PositionTex,p,0).xyz,1);
		float c	 = textureLod(InputTex,p,0).x;
		float w  = GaussianWeight(float(i),SigmaScreen) * GaussianWeight((d.z-dref.z),SigmaDepth);
		color 	+= w  * c;
		totalW  += w;
	}
	color	 /= totalW;
	FragColor = vec4(color);
}

shader SSAOFinalPS(out vec4 FragColor:0)
{
	vec2 pix	= gl_FragCoord.xy / vec2(textureSize(PositionTex,0));
	vec2 theta	= texture(RotationTex,pix).xy;
	vec4 c		= texture(PositionTex,pix);
	vec3 vn		= normalize( (ViewMatrix * vec4(texture(NormalTex,pix).xyz,0)).xyz );
	vec3 vc		= (ViewMatrix * c).xyz;
	float r 	= Radius * abs(Near/vc.z);
	float A 	= 0;
	mat2 rot 	= mat2(theta.x,theta.y,-theta.y,theta.x);

	for(int i=0;i<nSamples;++i)
	{
		vec2 samp	= pix + (rot*Samples[i])*r;
		vec4 p		= texture(PositionTex,samp);
		vec3 v		= (ViewMatrix * p).xyz - vc;
		A 			+= max(0.f,dot(v,vn) + v.z*Beta)  / (dot(v,v) + Epsilon);
	}
	// !!!! Gaussian Blur Shit....
	A 			= pow(max(0.f,1.f - 2.f*Sigma/float(nSamples)*A),Kappa);
	FragColor 	= vec4(A,A,A,A);
}

program SSAOBlur
{
	vs(430) = SSAOVS();
	fs(430) = SSAOBlurPS();
};

program SSAOFinal
{
	vs(430) = SSAOVS();
	fs(430) = SSAOFinalPS();
};
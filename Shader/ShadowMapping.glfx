
uniform mat4 MVP;
uniform mat4 MV;
uniform mat4 M;

uniform mat3 normalMatrix;
uniform mat4 shadowMatrix;

struct VS_OUT {
	smooth vec3 vEyeSpaceNormal;
	smooth vec3 vEyeSpacePosition;
	smooth vec4 vShadowCoords;
};

shader PCFShadowVS(
	in vec3 position:0,
	in vec3 normal:1,
	out VS_OUT vs_varying)
{
	vs_varying.vEyeSpacePosition 	= ( MV*vec4(position,1) ).xyz;
	vs_varying.vEyeSpaceNormal 		= normalMatrix * normal;
	vs_varying.vShadowCoords 		= shadowMatrix * ( M*vec4(position,1) );
	
	gl_Position 					= MVP*vec4(position, 1);
}


uniform sampler2DShadow shadowMap;
uniform vec3 lightPosition;
uniform vec3 diffuseColor;
uniform bool bIsLightPass;

const float k0 = 1.0;
const float k1 = 0.0;
const float k2 = 0.0;

float random(vec4 seed) {
	float d = dot(seed, vec4(12.9898, 78.233, 45.164, 94.673));
	return fract(sin(d)*43758.5453);
}

shader PCFShadowFS(in VS_OUT vs_varying, out vec4 FragColor:0)
{
	if(bIsLightPass) 
		return;
		
	vec4 eyeSpaceLightPosition = MV * vec4(lightPosition, 1);
	vec3 lightVector = (eyeSpaceLightPosition.xyz - vs_varying.vEyeSpacePosition);
	float d = length(L);
	lightVector = normalize(lightVector);
	
	float attenuationAmount = 1.0/( k1+ k1*d + k2*d*d );
	float diffuse = max( dot(vs_varying.vEyeSpaceNormal, lightVector) ) * attenuationAmount;
	
	vec4 vShadowCoords = vs_varying.vShadowCoords;
	if(vShadowCoords.w > 1) {
		float sum = 0;
		float shadow = 1;

		//using 3x3 neighborhood
		#ifdef STRATIFIED_3x3
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-2,-2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-2, 0));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-2, 2));

		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 0,-2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 0, 0));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 0, 2));

		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 2,-2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 2, 0));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 2, 2));
		shadow = sum/9.0;
		#endif
		
		//using 4x4 neighborhood
		#ifdef STRATIFIED_4x4
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-2,-2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-1,-2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 1,-2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 2,-2));

		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-2,-1));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-1,-1));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 1,-1));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 2,-1));

		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-2, 1));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-1, 1));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 1, 1));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 2, 1));
 
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-2, 2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2(-1, 2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 1, 2));
		sum += textureProjOffset(shadowMap, vShadowCoords, ivec2( 2, 2));

		shadow = sum/16.0;
		#endif

		#ifdef RANDOM_SAMPLING	 
		for(int i=0;i<16;i++) {
			float indexA = (random(vec4(gl_FragCoord.xyx, i))*0.25);
			float indexB = (random(vec4(gl_FragCoord.yxy, i))*0.25); 
			sum += textureProj(shadowMap, vShadowCoords+vec4(indexA, indexB, 0, 0));
		}
		shadow = sum/16.0;
		#endif

		//based on the value of shadow, the fragment is lightened/darkened
		diffuse = mix(diffuse, diffuse*shadow, 0.5); 
	}
	
	FragColor = diffuse * vec4(diffuseColor, 1);	
}


program PCFShadowMapping {
	vs(430) = PCFShadowVS();
	fs(430) = PCFShadowFS();
};